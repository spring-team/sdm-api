{"version":3,"file":"/Users/rodjohnson/sforzando-dev/idea-projects/my-flow/src/util/misc/spawned.ts","sources":["/Users/rodjohnson/sforzando-dev/idea-projects/my-flow/src/util/misc/spawned.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;GAcG;;;;;;;;;;AAEH,kEAAoD;AACpD,iDAAkE;AAGlE,2CAAqC;AAErC,yCAAyC;AACzC,4GAAuG;AAWvG;;;;;GAKG;AACU,QAAA,2BAA2B,GAAgB,IAAI,CAAC,EAAE,CAAC,IAAI,KAAK,CAAC,CAAC;AAa3E;;;;;;;GAOG;AACH,uBAAoC,YAA0B,EAC1B,OAAqB,EACrB,GAAgB,EAChB,SAAqC,EAAE;;QACvE,MAAM,YAAY,GAAG,qBAAK,CAAC,YAAY,CAAC,OAAO,EAAE,YAAY,CAAC,IAAI,IAAI,EAAE,EAAE,OAAO,CAAC,CAAC;QACnF,0BAAM,CAAC,IAAI,CAAC,6BAA6B,EAAE,OAAO,CAAC,GAAG,EAAE,qBAAqB,CAAC,YAAY,CAAC,EAAE,YAAY,CAAC,GAAG,CAAC,CAAC;QAC/G,OAAO,YAAY,CAAC,YAAY,EAAE,GAAG,EAAE,MAAM,CAAC,CAAC;IACnD,CAAC;CAAA;AAPD,sCAOC;AAED;;;;;;;GAOG;AACH,sBAA6B,YAA0B,EAC1B,GAAgB,EAChB,OAAmC,EAAE;IAC9D,OAAO,IAAI,OAAO,CAAqB,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QACvD,MAAM,SAAS,mBACX,WAAW,EAAE,mCAA2B,EACxC,SAAS,EAAE,KAAK,IACb,IAAI,CACV,CAAC;QACF,IAAI,CAAC,SAAS,CAAC,WAAW,EAAE;YACxB,kGAAkG;YAClG,SAAS,CAAC,WAAW,GAAG,mCAA2B,CAAC;SACvD;QAED,MAAM,mBAAmB,GAAG,IAAI,uEAAkC,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;QAC9E,mBAAmB,IAAI;YACnB,MAAM,SAAS,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;YACtF,OAAO,mBAAmB,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QAChD,CAAC;QAED,YAAY,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;QAC1C,YAAY,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;QAC1C,YAAY,CAAC,WAAW,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,MAAM,EAAE,EAAE;YAC9C,0BAAM,CAAC,IAAI,CAAC,yCAAyC,EAAE,YAAY,CAAC,GAAG,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;YACvF,OAAO,CAAC;gBACJ,KAAK,EAAE,SAAS,CAAC,WAAW,CAAC,IAAI,EAAE,MAAM,EAAE,GAAG,CAAC;gBAC/C,IAAI;aACP,CAAC,CAAC;QACP,CAAC,CAAC,CAAC;QACH,YAAY,CAAC,WAAW,CAAC,OAAO,EAAE,GAAG,CAAC,EAAE;YACpC,yCAAyC;YACzC,0BAAM,CAAC,IAAI,CAAC,mBAAmB,EAAE,GAAG,CAAC,CAAC;YACtC,MAAM,CAAC,GAAG,CAAC,CAAC;QAChB,CAAC,CAAC,CAAC;IACP,CAAC,CAAC,CAAC;AACP,CAAC;AAnCD,oCAmCC;AAYD;;;;GAIG;AACH,+BAAsC,EAAgB;IAClD,OAAO,oBAAO,CAAC,OAAO,EAAE,EAAE,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;AAC5E,CAAC;AAFD,sDAEC;AAED;;;;;;GAMG;AACH,wBAA+B,QAAgB,EAAE,UAAwB,EAAE;IACvE,MAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAClC,OAAO;QACH,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;QACjB,IAAI,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;QACpB,OAAO;KACV,CAAC;AACN,CAAC;AAPD,wCAOC;AAED;;;;;GAKG;AACH,uBAA8B,YAA0B;IACpD,YAAY,CAAC,IAAI,EAAE,CAAC;IACpB,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE,CAAC,YAAY,CAAC,EAAE,CAAC,OAAO,EAAE,GAAG,EAAE;QAClE,OAAO,EAAE,CAAC;IACd,CAAC,CAAC,CAAC,CAAC;AACR,CAAC;AALD,sCAKC","sourcesContent":["/*\n * Copyright Â© 2018 Atomist, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { logger } from \"@atomist/automation-client\";\nimport { ChildProcess, spawn, SpawnOptions } from \"child_process\";\nimport { ProgressLog } from \"../../spi/log/ProgressLog\";\n\nimport { sprintf } from \"sprintf-js\";\n\nimport * as strip_ansi from \"strip-ansi\";\nimport {DelimitedWriteProgressLogDecorator} from \"../../common/log/DelimitedWriteProgressLogDecorator\";\n\n/**\n * Type that can react to the exit of a spawned child process, after\n * Node has terminated without reporting an error.\n * This is necessary only for commands that can return\n * a non-zero exit code on success.\n * @return whether this result should be considered an error.\n */\nexport type ErrorFinder = (code: number, signal: string, log: ProgressLog) => boolean;\n\n/**\n * Default ErrorFinder that regards return code 0 as success\n * @param {number} code\n * @return {boolean}\n * @constructor\n */\nexport const SuccessIsReturn0ErrorFinder: ErrorFinder = code => code !== 0;\n\nexport interface ChildProcessResult {\n    error: boolean;\n    code: number;\n    message?: string;\n}\n\nexport interface SpawnWatchOptions {\n    errorFinder: ErrorFinder;\n    stripAnsi: boolean;\n}\n\n/**\n * Spawn a process and watch\n * @param {SpawnCommand} spawnCommand\n * @param options options\n * @param {ProgressLog} log\n * @param {Partial<SpawnWatchOptions>} spOpts\n * @return {Promise<ChildProcessResult>}\n */\nexport async function spawnAndWatch(spawnCommand: SpawnCommand,\n                                    options: SpawnOptions,\n                                    log: ProgressLog,\n                                    spOpts: Partial<SpawnWatchOptions> = {}): Promise<ChildProcessResult> {\n    const childProcess = spawn(spawnCommand.command, spawnCommand.args || [], options);\n    logger.info(\"%s > %s (spawn with pid=%d)\", options.cwd, stringifySpawnCommand(spawnCommand), childProcess.pid);\n    return watchSpawned(childProcess, log, spOpts);\n}\n\n/**\n * Handle the result of a spawned process, streaming back\n * output to log\n * @param childProcess\n * @param {ProgressLog} log to write stdout and stderr to\n * @param opts: Options for error parsing, ANSI code stripping etc.\n * @return {Promise<ChildProcessResult>}\n */\nexport function watchSpawned(childProcess: ChildProcess,\n                             log: ProgressLog,\n                             opts: Partial<SpawnWatchOptions> = {}): Promise<ChildProcessResult> {\n    return new Promise<ChildProcessResult>((resolve, reject) => {\n        const optsToUse = {\n            errorFinder: SuccessIsReturn0ErrorFinder,\n            stripAnsi: false,\n            ...opts,\n        };\n        if (!optsToUse.errorFinder) {\n            // The caller specified undefined, which is an error. Ignore them, for they know not what they do.\n            optsToUse.errorFinder = SuccessIsReturn0ErrorFinder;\n        }\n\n        const newLineDelimitedLog = new DelimitedWriteProgressLogDecorator(log, \"\\n\");\n        function sendToLog(data) {\n            const formatted = optsToUse.stripAnsi ? strip_ansi(data.toString()) : data.toString();\n            return newLineDelimitedLog.write(formatted);\n        }\n\n        childProcess.stdout.on(\"data\", sendToLog);\n        childProcess.stderr.on(\"data\", sendToLog);\n        childProcess.addListener(\"exit\", (code, signal) => {\n            logger.info(\"Spawn exit (pid=%d): code=%d, signal=%s\", childProcess.pid, code, signal);\n            resolve({\n                error: optsToUse.errorFinder(code, signal, log),\n                code,\n            });\n        });\n        childProcess.addListener(\"error\", err => {\n            // Process could not be spawned or killed\n            logger.warn(\"Spawn failure: %s\", err);\n            reject(err);\n        });\n    });\n}\n\n/**\n * The first two arguments to Node spawn\n */\nexport interface SpawnCommand {\n\n    command: string;\n    args?: string[];\n    options?: any;\n}\n\n/**\n * toString for a SpawnCommand. Used for logging.\n * @param {SpawnCommand} sc\n * @return {string}\n */\nexport function stringifySpawnCommand(sc: SpawnCommand): string {\n    return sprintf(\"%s %s\", sc.command, !!sc.args ? sc.args.join(\" \") : \"\");\n}\n\n/**\n * Convenient function to create a spawn command from a sentence such as \"npm run compile\"\n * Does not respect quoted arguments\n * @param {string} sentence\n * @param options\n * @return {SpawnCommand}\n */\nexport function asSpawnCommand(sentence: string, options: SpawnOptions = {}): SpawnCommand {\n    const split = sentence.split(\" \");\n    return {\n        command: split[0],\n        args: split.slice(1),\n        options,\n    };\n}\n\n/**\n * Kill the child process and wait for it to shut down. This can take a while as child processes\n * may have shut down hooks.\n * @param {module:child_process.ChildProcess} childProcess\n * @return {Promise<any>}\n */\nexport function poisonAndWait(childProcess: ChildProcess): Promise<any> {\n    childProcess.kill();\n    return new Promise((resolve, reject) => childProcess.on(\"close\", () => {\n        resolve();\n    }));\n}\n"]}