{"version":3,"file":"/Users/rodjohnson/sforzando-dev/idea-projects/my-flow/src/handlers/events/delivery/goals/executeGoal.ts","sources":["/Users/rodjohnson/sforzando-dev/idea-projects/my-flow/src/handlers/events/delivery/goals/executeGoal.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;GAcG;;;;;;;;;;AAEH,kEAAqG;AACrG,gEAA8D;AAC9D,6BAA6B;AAG7B,6EAAgG;AAChG,+FAAmI;AAInI,2DAA8D;AAE9D,2CAAqC;AAErC,iDAAiD;AACjD,kEAA+D;AAE/D;;;;;;;;;GASG;AACH,qBAAkC,KAAuC,EACvC,OAA2B,EAC3B,IAAuB,EACvB,OAAgB,EAChB,IAAU,EACV,cAA4B;;QAC1D,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC;QACzB,MAAM,EAAC,eAAe,EAAE,WAAW,EAAE,EAAE,EAAC,GAAG,IAAI,CAAC;QAChD,MAAM,kBAAkB,GAAG,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC;QACpD,0BAAM,CAAC,IAAI,CAAC,WAAW,OAAO,CAAC,IAAI,kBAAkB,OAAO,CAAC,KAAK,YAAY,OAAO,CAAC,WAAW,KAAK,OAAO,CAAC,WAAW,EAAE,CAAC,CAAC;QAE7H,MAAM,iBAAiB,CAAC,EAAC,GAAG,EAAE,OAAO,EAAE,IAAI,EAAE,cAAc,EAAE,WAAW,CAAC,GAAG,EAAC,CAAC,CAAC;QAC/E,IAAI;YACA,mBAAmB;YACnB,IAAI,MAAM,GAAQ,MAAM,WAAW,CAAC,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;YAEjE,wDAAwD;YACxD,IAAI,MAAM,CAAC,IAAI,KAAK,CAAC,EAAE;gBACnB,0BAA0B;gBAC1B,IAAI,UAAU,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC;qBAC/B,KAAK,CAAC,GAAG,CAAC,EAAE;oBACL,WAAW,CAAC,KAAK,CAAC,gBAAgB,GAAG,GAAG,CAAC,OAAO,GAAG,IAAI,CAAC,CAAC;oBACzD,WAAW,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;oBAC7B,WAAW,CAAC,KAAK,CAAC,oBAAO,CAAC,yBAAyB,EAAE,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;oBAEtE,OAAO,iCAAe,CAAC;wBACnB,IAAI,EAAE,kBAAkB,EAAE,eAAe,EAAE,WAAW,EAAE,EAAE,EAAE,cAAc;qBAC7E,EAAE,GAAG,CAAC;yBACF,IAAI,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;gBACzC,CAAC,CACJ,CAAC;gBACN,IAAI,CAAC,UAAU,EAAE;oBACb,0BAAM,CAAC,KAAK,CAAC,gDAAgD,EAAE,kBAAkB,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC;oBACjG,UAAU,GAAG,2BAAO,CAAC;iBACxB;gBAED,MAAM,qBACC,MAAM,EACN,UAAU,CAChB,CAAC;aACL;YAED,oBAAoB;YACpB,IAAI,MAAM,CAAC,IAAI,KAAK,CAAC,EAAE;gBACnB,IAAI,UAAU,GAAG,MAAM,WAAW,CAAC,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;gBACjE,IAAI,CAAC,UAAU,EAAE;oBACb,UAAU,GAAG,2BAAO,CAAC;iBACxB;gBACD,MAAM,qBACC,MAAM,EACN,UAAU,CAChB,CAAC;aACL;iBAAM;gBACH,MAAM,iCAAe,CAAC,EAAC,IAAI,EAAE,kBAAkB,EAAE,eAAe,EAAE,WAAW,EAAE,EAAE,EAAE,cAAc,EAAC,EAC9F,IAAI,KAAK,CAAC,oBAAoB,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;aACzD;YAED,0BAAM,CAAC,IAAI,CAAC,+BAA+B,EAAE,kBAAkB,EAAE,MAAM,CAAC,CAAC;YACzE,MAAM,UAAU,CAAC,EAAC,GAAG,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,cAAc,EAAE,WAAW,CAAC,GAAG,EAAC,CAAC,CAAC;YAChF,OAAO,2BAAO,CAAC;SAClB;QAAC,OAAO,GAAG,EAAE;YACV,0BAAM,CAAC,IAAI,CAAC,8BAA8B,EACtC,kBAAkB,EAAE,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,OAAO,CAAC,CAAC;YAClD,0BAAM,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YACvB,MAAM,UAAU,CAAC,EAAC,GAAG,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,EAAC,IAAI,EAAE,CAAC,EAAC,EAAE,KAAK,EAAE,GAAG,EAAE,cAAc,EAAE,WAAW,CAAC,GAAG,EAAC,CAAC,CAAC;YACvG,OAAO,2BAAO,CAAC,GAAG,CAAC,CAAC;SACvB;IACL,CAAC;CAAA;AAnED,kCAmEC;AAED,qBAAkC,KAAuC,EACvC,IAAuB,EACvB,OAAgB,EAChB,KAAqB;;QACnD,MAAM,EAAC,aAAa,EAAC,GAAG,KAAK,CAAC;QAC9B,MAAM,EAAC,WAAW,EAAE,EAAE,EAAE,OAAO,EAAE,WAAW,EAAC,GAAG,IAAI,CAAC;QACrD,OAAO,aAAa,CAAC,aAAa,CAAC,EAAC,WAAW,EAAE,EAAE,EAAE,OAAO,EAAE,QAAQ,EAAE,IAAI,EAAC,EAAE,CAAM,CAAC,EAAC,EAAE;YACrF,MAAM,IAAI,GAAG,cAAc,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;YAC5C,IAAI,CAAC,CAAC,cAAc,CAAC,kBAAkB,IAAI,EAAE,CAAC,EAAE;gBAE5C,0BAAM,CAAC,IAAI,CAAC,4BAA4B,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;gBAEvD,MAAM,IAAI,GAAG;oBACT,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,EAAE,UAAU,EAAE,OAAO,CAAC;oBAC9C,GAAG,oBACI,OAAO,CAAC,GAAG;wBACd,kDAAkD;wBAClD,6FAA6F;wBAC7F,eAAe;wBACf,yEAAyE;wBACzE,gFAAgF;wBAChF,YAAY,EAAE,iBAAO,CAAC,WAAW,CAAC,EAClC,YAAY,EAAE,OAAO,CAAC,MAAM,EAC5B,sBAAsB,EAAE,OAAO,CAAC,aAAa,EAC7C,WAAW,EAAE,kBAAQ,EAAE,GAC1B;iBACJ,CAAC;gBAEF,IAAI,MAAM,GAAkB,MAAM,uBAAa,CAC3C,EAAC,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,EAAE,UAAU,EAAE,OAAO,EAAE,IAAI,CAAC,EAAE,IAAI,EAAE,EAAE,EAAC,EACpE,IAAI,EACJ,WAAW,EACX;oBACI,WAAW,EAAE,IAAI,CAAC,EAAE,CAAC,IAAI,KAAK,CAAC;iBAClC,CAAC,CAAC;gBAEP,IAAI,CAAC,MAAM,EAAE;oBACT,MAAM,GAAG,2BAAO,CAAC;iBACpB;gBAED,0BAAM,CAAC,IAAI,CAAC,2BAA2B,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;gBACxD,OAAO,MAAM,CAAC;aACjB;YACD,OAAO,2BAAO,CAAC;QACnB,CAAC,CAAA,CAAC,CAAC;IACP,CAAC;CAAA;AA7CD,kCA6CC;AAED,wBAAwB,OAAgB,EAAE,MAAc;IACpD,OAAO,GAAG,MAAM,IAAI,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,OAAO,CAAC,IAAI,EAAE,CAAC;AACvE,CAAC;AAED,oBAA2B,UAG1B;IACG,MAAM,EAAC,GAAG,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,cAAc,EAAC,GAAG,UAAU,CAAC;IACvE,MAAM,QAAQ,GAAG,MAAM,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;QAC5C,MAAM,CAAC,eAAe,CAAC,CAAC,CAAC,sBAAsB,CAAC,CAAC,CAAC,SAAS,CAAC;IAChE,qGAAqG;IACrG,2EAA2E;IAC3E,MAAM,GAAG,GAAG,MAAM,CAAC,SAAS,IAAI,cAAc,CAAC;IAC/C,OAAO,uBAAU,CAAC,GAAG,EAAE,OAAO,EAC1B;QACI,GAAG;QACH,KAAK,EAAE,QAAQ;QACf,WAAW,EAAE,iCAAoB,CAAC,IAAI,EAAE,QAAQ,CAAC;QACjD,KAAK;KACR,CAAC,CAAC;AACX,CAAC;AAjBD,gCAiBC;AAED,2BAA2B,UAAyF;IAChH,MAAM,EAAC,GAAG,EAAE,OAAO,EAAE,IAAI,EAAE,cAAc,EAAC,GAAG,UAAU,CAAC;IACxD,OAAO,uBAAU,CAAC,GAAG,EAAE,OAAO,EAAE;QAC5B,GAAG,EAAE,cAAc;QACnB,WAAW,EAAE,IAAI,CAAC,oBAAoB;QACtC,KAAK,EAAE,YAAY;KACtB,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,CACX,0BAAM,CAAC,IAAI,CAAC,8DAA8D,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;AAEhG,CAAC","sourcesContent":["/*\n * Copyright Â© 2018 Atomist, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { failure, HandlerContext, HandlerResult, logger, Success } from \"@atomist/automation-client\";\nimport { jwtToken } from \"@atomist/automation-client/globals\";\nimport * as path from \"path\";\nimport { ExecuteGoalResult } from \"../../../../common/delivery/goals/ExecuteGoalResult\";\nimport { Goal } from \"../../../../common/delivery/goals/Goal\";\nimport { descriptionFromState, updateGoal } from \"../../../../common/delivery/goals/storeGoals\";\nimport { ExecuteGoalWithLog, reportGoalError, RunWithLogContext } from \"../../../../common/delivery/goals/support/reportGoalError\";\nimport { ProjectLoader } from \"../../../../common/repo/ProjectLoader\";\nimport { SdmGoal } from \"../../../../ingesters/sdmGoalIngester\";\nimport { InterpretLog } from \"../../../../spi/log/InterpretedLog\";\nimport { spawnAndWatch } from \"../../../../util/misc/spawned\";\n\nimport { sprintf } from \"sprintf-js\";\n\nimport * as stringify from \"json-stringify-safe\";\nimport { toToken } from \"../../../../util/credentials/toToken\";\n\n/**\n * Central function to execute a goal with progress logging\n * @param {{projectLoader: ProjectLoader}} rules\n * @param {ExecuteGoalWithLog} execute\n * @param {RunWithLogContext} rwlc\n * @param {SdmGoal} sdmGoal\n * @param {Goal} goal\n * @param {InterpretLog} logInterpreter\n * @return {Promise<ExecuteGoalResult>}\n */\nexport async function executeGoal(rules: { projectLoader: ProjectLoader },\n                                  execute: ExecuteGoalWithLog,\n                                  rwlc: RunWithLogContext,\n                                  sdmGoal: SdmGoal,\n                                  goal: Goal,\n                                  logInterpreter: InterpretLog): Promise<ExecuteGoalResult> {\n    const ctx = rwlc.context;\n    const {addressChannels, progressLog, id} = rwlc;\n    const implementationName = sdmGoal.fulfillment.name;\n    logger.info(`Running ${sdmGoal.name}. Triggered by ${sdmGoal.state} status: ${sdmGoal.externalKey}: ${sdmGoal.description}`);\n\n    await markGoalInProcess({ctx, sdmGoal, goal, progressLogUrl: progressLog.url});\n    try {\n        // execute pre hook\n        let result: any = await executeHook(rules, rwlc, sdmGoal, \"pre\");\n\n        // TODO CD is there a isSuccess(result) method somewhere\n        if (result.code === 0) {\n            // execute the actual goal\n            let goalResult = await execute(rwlc)\n                .catch(err => {\n                        progressLog.write(\"ERROR caught: \" + err.message + \"\\n\");\n                        progressLog.write(err.stack);\n                        progressLog.write(sprintf(\"Full error object: [%s]\", stringify(err)));\n\n                        return reportGoalError({\n                            goal, implementationName, addressChannels, progressLog, id, logInterpreter,\n                        }, err)\n                            .then(() => Promise.reject(err));\n                    },\n                );\n            if (!goalResult) {\n                logger.error(\"Execute method for %s of %s returned undefined\", implementationName, sdmGoal.name);\n                goalResult = Success;\n            }\n\n            result = {\n                ...result,\n                ...goalResult,\n            };\n        }\n\n        // execute post hook\n        if (result.code === 0) {\n            let hookResult = await executeHook(rules, rwlc, sdmGoal, \"post\");\n            if (!hookResult) {\n                hookResult = Success;\n            }\n            result = {\n                ...result,\n                ...hookResult,\n            };\n        } else {\n            await reportGoalError({goal, implementationName, addressChannels, progressLog, id, logInterpreter},\n                new Error(\"Failure reported: \" + result.message));\n        }\n\n        logger.info(\"ExecuteGoal: result of %s: %j\", implementationName, result);\n        await markStatus({ctx, sdmGoal, goal, result, progressLogUrl: progressLog.url});\n        return Success;\n    } catch (err) {\n        logger.warn(\"Error executing %s on %s: %s\",\n            implementationName, sdmGoal.sha, err.message);\n        logger.warn(err.stack);\n        await markStatus({ctx, sdmGoal, goal, result: {code: 1}, error: err, progressLogUrl: progressLog.url});\n        return failure(err);\n    }\n}\n\nexport async function executeHook(rules: { projectLoader: ProjectLoader },\n                                  rwlc: RunWithLogContext,\n                                  sdmGoal: SdmGoal,\n                                  stage: \"post\" | \"pre\"): Promise<HandlerResult> {\n    const {projectLoader} = rules;\n    const {credentials, id, context, progressLog} = rwlc;\n    return projectLoader.doWithProject({credentials, id, context, readOnly: true}, async p => {\n        const hook = goalToHookFile(sdmGoal, stage);\n        if (p.fileExistsSync(`.atomist/hooks/${hook}`)) {\n\n            logger.info(\"Invoking goal %s hook '%s'\", stage, hook);\n\n            const opts = {\n                cwd: path.join(p.baseDir, \".atomist\", \"hooks\"),\n                env: {\n                    ...process.env,\n                    // TODO cd do we need more variables to pass over?\n                    // jess: I vote for passing the fewest possible -- like just correlation ID maybe, to show it\n                    // can be done.\n                    // This is an interface that is easy to expand and very hard to contract.\n                    // plus, this is secure information; must we provide it to a script in any repo?\n                    GITHUB_TOKEN: toToken(credentials),\n                    ATOMIST_TEAM: context.teamId,\n                    ATOMIST_CORRELATION_ID: context.correlationId,\n                    ATOMIST_JWT: jwtToken(),\n                },\n            };\n\n            let result: HandlerResult = await spawnAndWatch(\n                {command: path.join(p.baseDir, \".atomist\", \"hooks\", hook), args: []},\n                opts,\n                progressLog,\n                {\n                    errorFinder: code => code !== 0,\n                });\n\n            if (!result) {\n                result = Success;\n            }\n\n            logger.info(\"Goal %s hook returned: %j\", stage, result);\n            return result;\n        }\n        return Success;\n    });\n}\n\nfunction goalToHookFile(sdmGoal: SdmGoal, prefix: string): string {\n    return `${prefix}-${sdmGoal.environment.slice(2)}-${sdmGoal.name}`;\n}\n\nexport function markStatus(parameters: {\n    ctx: HandlerContext, sdmGoal: SdmGoal, goal: Goal, result: ExecuteGoalResult,\n    error?: Error, progressLogUrl: string,\n}) {\n    const {ctx, sdmGoal, goal, result, error, progressLogUrl} = parameters;\n    const newState = result.code !== 0 ? \"failure\" :\n        result.requireApproval ? \"waiting_for_approval\" : \"success\";\n    // Currently, the goals tend to have a single url so it seems safe to use whichever of these we have.\n    // Going forward it may make sense to have both a logging and a result URL.\n    const url = result.targetUrl || progressLogUrl;\n    return updateGoal(ctx, sdmGoal,\n        {\n            url,\n            state: newState,\n            description: descriptionFromState(goal, newState),\n            error,\n        });\n}\n\nfunction markGoalInProcess(parameters: { ctx: HandlerContext, sdmGoal: SdmGoal, goal: Goal, progressLogUrl: string }) {\n    const {ctx, sdmGoal, goal, progressLogUrl} = parameters;\n    return updateGoal(ctx, sdmGoal, {\n        url: progressLogUrl,\n        description: goal.inProcessDescription,\n        state: \"in_process\",\n    }).catch(err =>\n        logger.warn(\"Failed to update %s goal to tell people we are working on it\", goal.name));\n\n}\n"]}