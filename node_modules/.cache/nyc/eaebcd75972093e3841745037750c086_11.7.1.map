{"version":3,"file":"/Users/rodjohnson/sforzando-dev/idea-projects/my-flow/src/util/fingerprint/elementRequest.ts","sources":["/Users/rodjohnson/sforzando-dev/idea-projects/my-flow/src/util/fingerprint/elementRequest.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;GAcG;;;;;;;;;;AAGH,2EAA2E;AAK3E,qGAAkG;AAClG,qCAA2C;AAC3C,yEAAsE;AAyCtE;;;;;GAKG;AACH,sBAAmC,CAAU,EACV,OAAgC,EAAE;;QACjE,MAAM,SAAS,qBACR,mDAAwB,EACxB,IAAI,CACV,CAAC;QACF,MAAM,OAAO,GAAG,MAAM,sBAAW,CAAC,CAAC,EAC/B,SAAS,CAAC,UAAU,EACpB,SAAS,CAAC,WAAW,EACrB,SAAS,CAAC,cAAc,CAC3B,CAAC;QACF,MAAM,MAAM,GAAG,IAAI,qCAAiB,EAAE,CAAC;QACvC,OAAO,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;YACnB,MAAM,UAAU,GAAG,SAAS,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC;YAClD,MAAM,IAAI,GAAG,CAAC,CAAC,MAAM,CAAC;YACtB,MAAM,aAAa,GAAG,CAAC,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAE,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;YACxG,OAAO;gBACH,IAAI,EAAE,CAAC;gBACP,IAAI,EAAE,CAAC,CAAC,cAAc,CAAC,IAAI;gBAC3B,UAAU;gBACV,IAAI;gBACJ,aAAa;gBACb,GAAG,EAAE,kBAAY,CAAC,aAAa,CAAC;aACnC,CAAC;QACN,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,SAAS,CAAC,iBAAiB,IAAI,SAAS,CAAC,iBAAiB,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC;IACvG,CAAC;CAAA;AAzBD,oCAyBC","sourcesContent":["/*\n * Copyright Â© 2018 Atomist, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Project } from \"@atomist/automation-client/project/Project\";\nimport { findMatches } from \"@atomist/automation-client/tree/ast/astUtils\";\nimport { MatchResult } from \"@atomist/automation-client/tree/ast/FileHits\";\nimport { FileParser } from \"@atomist/automation-client/tree/ast/FileParser\";\nimport { TreeNode } from \"@atomist/tree-path/TreeNode\";\n\nimport { CFamilyLangHelper } from \"@atomist/microgrammar/matchers/lang/cfamily/CFamilyLangHelper\";\nimport { computeShaOf } from \"../misc/sha\";\nimport { JavaScriptElementRequest } from \"./JavaScriptElementRequest\";\n\nexport interface ElementRequest {\n\n    /**\n     * Parser to use to parse the content\n     */\n    fileParser: FileParser;\n\n    /**\n     * Path expression for the elements we want\n     */\n    pathExpression: string;\n\n    /**\n     * Glob patterns for the files we want to parse\n     */\n    globPattern: string;\n\n    /**\n     * Regex to narrow identifier names if specified\n     */\n    identifierPattern?: RegExp;\n\n    /**\n     * Function to extract the identifier from each matched element\n     * @param {MatchResult} m\n     * @return {string}\n     */\n    extractIdentifier: (m: MatchResult) => string;\n\n    /**\n     * Return a canonical string from this element.\n     * Rules will be different for functions, classes etc.\n     * Default behavior is C comment removal and whitespace canonicalization\n     * @param {TreeNode} n matching node\n     * @return {string}\n     */\n    canonicalize?: (n: TreeNode) => string;\n}\n\n/**\n * Request the given elements in a language\n * @param {Project} p\n * @param {Partial<ElementRequest>} opts\n * @return {Promise<Element[]>}\n */\nexport async function findElements(p: Project,\n                                   opts: Partial<ElementRequest> = {}): Promise<Element[]> {\n    const optsToUse: ElementRequest = {\n        ...JavaScriptElementRequest,\n        ...opts,\n    };\n    const matches = await findMatches(p,\n        optsToUse.fileParser,\n        optsToUse.globPattern,\n        optsToUse.pathExpression,\n    );\n    const helper = new CFamilyLangHelper();\n    return matches.map(m => {\n        const identifier = optsToUse.extractIdentifier(m);\n        const body = m.$value;\n        const canonicalBody = !!optsToUse.canonicalize ? optsToUse.canonicalize(m) :  helper.canonicalize(body);\n        return {\n            node: m,\n            path: m.sourceLocation.path,\n            identifier,\n            body,\n            canonicalBody,\n            sha: computeShaOf(canonicalBody),\n        };\n    }).filter(sig => !optsToUse.identifierPattern || optsToUse.identifierPattern.test(sig.identifier));\n}\n\n/**\n * Function signature we've found\n */\nexport interface Element {\n\n    /**\n     * AST node. We can parse further if we wish\n     */\n    node: TreeNode;\n\n    /**\n     * Path of the file within the project\n     */\n    path: string;\n\n    /**\n     * Identifier of the element\n     */\n    identifier: string;\n\n    body: string;\n\n    /**\n     * Canonical body without comments or whitespace.\n     * Useful for sha-ing.\n     */\n    canonicalBody: string;\n\n    /**\n     * Sha computed from the canonical body\n     */\n    sha: string;\n}\n"]}