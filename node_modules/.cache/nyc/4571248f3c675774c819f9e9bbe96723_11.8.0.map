{"version":3,"file":"/Users/rodjohnson/sforzando-dev/idea-projects/my-flow/src/common/delivery/deploy/local/ManagedDeployments.ts","sources":["/Users/rodjohnson/sforzando-dev/idea-projects/my-flow/src/common/delivery/deploy/local/ManagedDeployments.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright Â© 2018 Atomist, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { logger } from \"@atomist/automation-client\";\nimport { RemoteRepoRef, RepoRef } from \"@atomist/automation-client/operations/common/RepoId\";\nimport axios from \"axios\";\nimport { ChildProcess } from \"child_process\";\nimport * as https from \"https\";\nimport { Deployment, TargetInfo } from \"../../../../spi/deploy/Deployment\";\nimport { poisonAndWait } from \"../../../../util/misc/spawned\";\nimport { Targeter } from \"../deploy\";\n\nexport interface ManagedDeploymentTargetInfo extends TargetInfo {\n    managedDeploymentKey: RemoteRepoRef;\n}\n\nexport const ManagedDeploymentTargeter: Targeter<ManagedDeploymentTargetInfo> = (id: RemoteRepoRef, branch: string) => {\n    const branchId = {...id, branch};\n    return {\n        name: \"Run alongside this automation\",\n        description: `Locally run ${id.sha} from branch ${branch}`,\n        managedDeploymentKey: branchId,\n    };\n};\n\n/**\n * Strategy for looking up a service\n */\nexport enum LookupStrategy {\n    service = \"service\",\n    branch = \"branch\",\n    sha = \"sha\",\n}\n\n/**\n * Ports will be reused for the same app\n */\nexport interface DeployedApp {\n\n    id: RepoRef;\n\n    port: number;\n\n    /** Will be undefined if the app is not currently deployed */\n    childProcess: ChildProcess;\n\n    deployment: Deployment;\n\n    lookupStrategy: LookupStrategy;\n}\n\n/**\n * Manages local deployments to the automation server node\n * This is not intended for production use\n * @type {Array}\n */\nexport class ManagedDeployments {\n\n    public readonly deployments: DeployedApp[] = [];\n\n    constructor(public initialPort: number) {\n    }\n\n    /**\n     * Find the appropriate port for this app\n     * @param {RemoteRepoRef} id\n     * @param lookupStrategy strategy for looking up the instance\n     * @param host it will be on. Check for ports not in use\n     * @return {number}\n     */\n    public async findPort(id: RemoteRepoRef, lookupStrategy: LookupStrategy, host: string): Promise<number> {\n        const running = this.findDeployment(id, lookupStrategy);\n        return !!running ? running.port : this.nextFreePort(host);\n    }\n\n    public recordDeployment(da: DeployedApp) {\n        logger.info(\"Recording app [%s:%s] on port [%d]\", da.id.owner, da.id.repo, da.port);\n        this.deployments.push(da);\n    }\n\n    public findDeployment(id: RemoteRepoRef, lookupStrategy: LookupStrategy): DeployedApp {\n        switch (lookupStrategy) {\n            case  LookupStrategy.sha :\n                if (!id.sha) {\n                    throw new Error(\"Sha should have been set to use 'sha' LookupStrategy\");\n                }\n                // Probability of a sha collision is tiny\n                return this.deployments.find(d => d.id.sha === id.sha);\n            case LookupStrategy.branch :\n                if (!id.branch) {\n                    throw new Error(\"Branch should have been set to use 'branch' LookupStrategy\");\n                }\n                return this.deployments\n                    .find(d => d.id.owner === id.owner && d.id.repo === id.repo && d.id.branch === id.branch);\n            case LookupStrategy.service:\n                this.deployments\n                    .find(d => d.id.owner === id.owner && d.id.repo === id.repo);\n        }\n    }\n\n    /**\n     * Terminate any process we're managing on behalf of this id\n     * @param {RemoteRepoRef} id\n     * @param lookupStrategy strategy for finding the instance\n     * @return {Promise<any>}\n     */\n    public async terminateIfRunning(id: RemoteRepoRef, lookupStrategy: LookupStrategy): Promise<any> {\n        const victim = this.findDeployment(id, lookupStrategy);\n        if (!!victim && !!victim.childProcess) {\n            await poisonAndWait(victim.childProcess);\n            // Keep the port but deallocate the process\n            logger.info(\"Killed app [%j] with pid %d, but continuing to reserve port [%d]\",\n                id, victim.childProcess.pid, victim.port);\n            victim.childProcess = undefined;\n        } else {\n            logger.info(\"Was asked to kill app [%j], but no eligible process found\", id);\n        }\n    }\n\n    private async nextFreePort(host: string): Promise<number> {\n        let port = this.initialPort;\n        while (true) {\n            if (this.deployments.some(d => d.port === port)) {\n                port++;\n            } else if (await portIsInUse(host, port)) {\n                // Skip this port, too\n                logger.warn(\"Unexpected: %s is serving on port %d\", host, port);\n                port++;\n            } else {\n                break;\n            }\n        }\n        return port;\n    }\n\n}\n\nasync function portIsInUse(host: string, port: number) {\n    const agent = new https.Agent({\n        rejectUnauthorized: false,\n    });\n    try {\n        await axios.head(`${host}:${port}`, {httpsAgent: agent});\n        return true;\n    } catch {\n        return false;\n    }\n}\n"]}