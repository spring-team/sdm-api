"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pathExpression_1 = require("./pathExpression");
class AttributeEqualityPredicate {
    constructor(name, value) {
        this.name = name;
        this.value = value;
    }
    evaluate(nodeToTest) {
        return nodeToTest.$value === this.value;
    }
    toString() {
        return `@${this.name}='${this.value}'`;
    }
}
exports.AttributeEqualityPredicate = AttributeEqualityPredicate;
/**
 * Position within results. Indexing starts from 1
 */
class PositionPredicate {
    constructor(index) {
        this.index = index;
    }
    evaluate(nodeToTest, returnedNodes) {
        return returnedNodes.indexOf(nodeToTest) === this.index - 1;
    }
    toString() {
        return `[${this.index}]'`;
    }
}
exports.PositionPredicate = PositionPredicate;
class NestedPathExpressionPredicate {
    constructor(pathExpression) {
        this.pathExpression = pathExpression;
    }
    evaluate(nodeToTest, returnedNodes, ee, functionRegistry) {
        const r = ee(nodeToTest, this.pathExpression, functionRegistry);
        return pathExpression_1.isSuccessResult(r) && r.length > 0;
    }
    toString() {
        return pathExpression_1.stringify(this.pathExpression);
    }
}
exports.NestedPathExpressionPredicate = NestedPathExpressionPredicate;
class OrPredicate {
    constructor(a, b) {
        this.a = a;
        this.b = b;
    }
    evaluate(nodeToTest, returnedNodes, ee, functionRegistry) {
        return this.a.evaluate(nodeToTest, returnedNodes, ee, functionRegistry) ||
            this.b.evaluate(nodeToTest, returnedNodes, ee, functionRegistry);
    }
    toString() {
        return `${this.a} or ${this.b}'`;
    }
}
exports.OrPredicate = OrPredicate;
//# sourceMappingURL=predicates.js.map