"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pathExpression_1 = require("./pathExpression");
const _ = require("lodash");
const pathExpressionUtils_1 = require("../internal/pathExpressionUtils");
const FunctionPredicate_1 = require("./FunctionPredicate");
const utils_1 = require("./utils");
/**
 * Return the result of evaluating the expression. If the expression is invalid
 * return a message, otherwise the result of invoking the valid expression.
 * All other functions ultimately run through this.
 *
 * @param root  root node to evaluateExpression the path against
 * @param pex   Parsed or string path expression.
 * @param functionRegistry registry to use to look up functions
 * @return ExecutionResult
 */
function evaluateExpression(root, pex, functionRegistry = {}) {
    const parsed = utils_1.toPathExpression(pex);
    const failure = validateFunctionPredicates(parsed, functionRegistry);
    if (pathExpression_1.isFailureResult(failure)) {
        return failure;
    }
    if (pathExpression_1.isUnionPathExpression(parsed)) {
        const results = parsed.unions.map(u => evaluateExpression(root, u));
        const fail = results.find(pathExpression_1.isFailureResult);
        if (!!fail) {
            return fail;
        }
        return _.uniq(_.flatten(results.map(r => r)));
    }
    let currentResult = [root];
    for (const locationStep of parsed.locationSteps) {
        if (pathExpression_1.isSuccessResult(currentResult)) {
            if (currentResult.length > 0) {
                const allNextNodes = currentResult.map(n => locationStep.follow(n, root, evaluateExpression, functionRegistry));
                const next = _.flatten(allNextNodes);
                // console.debug("Executing location step %s against [%s]:count=%d",
                //     locationStep,
                //     currentResult.map(n => n.$name).join(","),
                //     next.length);
                currentResult = next;
            }
        }
        else {
            return currentResult;
        }
    }
    return currentResult;
}
exports.evaluateExpression = evaluateExpression;
function validateFunctionPredicates(pex, functionRegistry) {
    const functionPredicates = pathExpressionUtils_1.allPredicates(pex)
        .filter(FunctionPredicate_1.isFunctionPredicate)
        .map(f => f);
    const missingFunctions = functionPredicates
        .filter(fp => !functionRegistry[fp.name])
        .map(fp => fp.name);
    if (missingFunctions.length > 0) {
        return `Function predicate '${missingFunctions.join()}' not found in registry`;
    }
}
/**
 * Convenience method to return the result of evaluating the $value of the scalar expression,
 * which is usually a terminal.
 * Undefined if there is not exactly one.
 *
 * @param root  root node to evaluateExpression the path against
 * @param pex   Parsed or string path expression.
 * @param functionRegistry registry to use to look up functions
 * @return
 */
function evaluateScalar(root, pex, functionRegistry = {}) {
    const results = evaluateExpression(root, pex, functionRegistry);
    if (pathExpression_1.isSuccessResult(results) && results.length === 1) {
        return results[0];
    }
    else {
        return undefined;
    }
}
exports.evaluateScalar = evaluateScalar;
/**
 * Convenience method to return the result of evaluating the $value of the scalar expression,
 * which is usually a terminal.
 * Undefined if there is not exactly one.
 *
 * @param root  root node to evaluateExpression the path against
 * @param pex   Parsed or string path expression.
 * @param functionRegistry registry to use to look up functions
 * @return
 */
function evaluateScalarValue(root, pex, functionRegistry = {}) {
    const node = evaluateScalar(root, pex, functionRegistry);
    return node ? node.$value : undefined;
}
exports.evaluateScalarValue = evaluateScalarValue;
/**
 * Convenience method to return an array of literal $value's
 * of the nodes returned by the expression, which usually matches terminals.
 * Returns the empty array without error if there are 0.
 *
 * @param root  root node to evaluateExpression the path against
 * @param pex   Parsed or string path expression.
 * @param functionRegistry registry to use to look up functions
 * @return
 */
function evaluateScalarValues(root, pex, functionRegistry = {}) {
    const values = (evaluateExpression(root, pex, functionRegistry));
    return pathExpression_1.isSuccessResult(values) ?
        values.map(n => n.$value) :
        [];
}
exports.evaluateScalarValues = evaluateScalarValues;
//# sourceMappingURL=expressionEngine.js.map