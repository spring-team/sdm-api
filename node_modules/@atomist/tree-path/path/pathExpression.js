"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
function isSuccessResult(a) {
    return !!a && !!a.length;
}
exports.isSuccessResult = isSuccessResult;
function isFailureResult(a) {
    return typeof a === "string";
}
exports.isFailureResult = isFailureResult;
/**
 * Step within a path expression
 */
class LocationStep {
    constructor(axis, test, predicates) {
        this.axis = axis;
        this.test = test;
        this.predicates = predicates;
    }
    follow(tn, root, ee, functionRegistry = {}) {
        const allNodes = this.axis.follow(tn, root)
            .filter(n => this.test.test(n, ee));
        return allNodes.filter(n => !this.predicates.some(pred => !pred.evaluate(n, allNodes, ee, functionRegistry)));
    }
    toString() {
        const preds = this.predicates.length > 0 ?
            this.predicates.map(p => `[${p}]`).join("") :
            "";
        return `${this.axis.type}::${this.test}${preds}`;
    }
}
exports.LocationStep = LocationStep;
function isUnionPathExpression(pe) {
    return !!pe.unions;
}
exports.isUnionPathExpression = isUnionPathExpression;
/**
 * Create a Union path expression from the given array of strings or PathExpression
 * instances
 * @param {Array<string | PathExpression>} pathExpressions
 * @return {UnionPathExpression}
 */
function unionOf(pathExpressions) {
    return {
        unions: pathExpressions.map(utils_1.toPathExpression),
    };
}
exports.unionOf = unionOf;
/**
 * Return an informative string representation of the given path expression
 * @param {PathExpression} pe
 * @return {string}
 */
function stringify(pe) {
    return isUnionPathExpression(pe) ?
        pe.unions.map(stringify).join(" | ") :
        pe.locationSteps.map(l => "" + l).join("/");
}
exports.stringify = stringify;
//# sourceMappingURL=pathExpression.js.map