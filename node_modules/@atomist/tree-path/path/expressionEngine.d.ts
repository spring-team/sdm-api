import { TreeNode } from "../TreeNode";
import { ExecutionResult, PathExpression } from "./pathExpression";
export declare type ExpressionEngine = (node: TreeNode, parsed: PathExpression | string, functionRegistry: object) => ExecutionResult;
/**
 * Return the result of evaluating the expression. If the expression is invalid
 * return a message, otherwise the result of invoking the valid expression.
 * All other functions ultimately run through this.
 *
 * @param root  root node to evaluateExpression the path against
 * @param pex   Parsed or string path expression.
 * @param functionRegistry registry to use to look up functions
 * @return ExecutionResult
 */
export declare function evaluateExpression(root: TreeNode, pex: string | PathExpression, functionRegistry?: object): ExecutionResult;
/**
 * Convenience method to return the result of evaluating the $value of the scalar expression,
 * which is usually a terminal.
 * Undefined if there is not exactly one.
 *
 * @param root  root node to evaluateExpression the path against
 * @param pex   Parsed or string path expression.
 * @param functionRegistry registry to use to look up functions
 * @return
 */
export declare function evaluateScalar(root: TreeNode, pex: string | PathExpression, functionRegistry?: object): TreeNode;
/**
 * Convenience method to return the result of evaluating the $value of the scalar expression,
 * which is usually a terminal.
 * Undefined if there is not exactly one.
 *
 * @param root  root node to evaluateExpression the path against
 * @param pex   Parsed or string path expression.
 * @param functionRegistry registry to use to look up functions
 * @return
 */
export declare function evaluateScalarValue(root: TreeNode, pex: string | PathExpression, functionRegistry?: object): string | undefined;
/**
 * Convenience method to return an array of literal $value's
 * of the nodes returned by the expression, which usually matches terminals.
 * Returns the empty array without error if there are 0.
 *
 * @param root  root node to evaluateExpression the path against
 * @param pex   Parsed or string path expression.
 * @param functionRegistry registry to use to look up functions
 * @return
 */
export declare function evaluateScalarValues(root: TreeNode, pex: string | PathExpression, functionRegistry?: object): string[];
