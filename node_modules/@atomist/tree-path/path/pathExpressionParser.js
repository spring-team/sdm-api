"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Concat_1 = require("@atomist/microgrammar/matchers/Concat");
const Microgrammar_1 = require("@atomist/microgrammar/Microgrammar");
const Ops_1 = require("@atomist/microgrammar/Ops");
const PatternMatch_1 = require("@atomist/microgrammar/PatternMatch");
const Primitives_1 = require("@atomist/microgrammar/Primitives");
const Rep_1 = require("@atomist/microgrammar/Rep");
const axisSpecifiers_1 = require("./axisSpecifiers");
const FunctionPredicate_1 = require("./FunctionPredicate");
const nodeTests_1 = require("./nodeTests");
const pathExpression_1 = require("./pathExpression");
const predicates_1 = require("./predicates");
/**
 * Parse the given string to path expression. Throw an error in the event of failure.
 * @param {string} expr expression ot path
 * @return {PathExpression}
 */
function parsePathExpression(expr) {
    const pg = PredicateGrammarDefs;
    // TODO the _initialized property is being added to microgrammar LazyMatcher
    // to avoid the need for adding a property here
    if (!pg._initialized) {
        pg._term = Ops_1.firstOf(ValuePredicateGrammar, PositionPredicateGrammar, SimplePathExpressionGrammarDefs, FunctionPredicateGrammar);
        pg._initialized = true;
        PredicateGrammar._init();
    }
    const m = PathExpressionGrammar.exactMatch(expr);
    if (PatternMatch_1.isPatternMatch(m)) {
        // logger.debug("Successfully parsed path expression [%s]: %s", expr, stringify(m));
        return m.pathExpression;
    }
    else {
        // logger.info("Error parsing path expression [%s]: %s", expr, JSON.stringify(m));
        throw new Error("Failure: " + JSON.stringify(m));
    }
}
exports.parsePathExpression = parsePathExpression;
const NodeName = /[.a-zA-Z0-9_\-$#]+/;
// TODO allow double quotes, and string escaping, and possibly integer literals
const ValuePredicateGrammar = Microgrammar_1.Microgrammar.fromString("@${name}='${value}'");
const FunctionPredicateGrammar = Microgrammar_1.Microgrammar.fromString("?${functionName}", {
    functionName: /[a-zA-Z_][a-zA-Z0-9_]*/,
});
const PositionPredicateGrammar = Microgrammar_1.Microgrammar.fromString("${position}", { position: Primitives_1.Integer });
const PredicateGrammarDefs = {
    _lb: "[",
    _term: null,
    term: ctx => {
        if (!!ctx._term.name && !!ctx._term.value) {
            return new predicates_1.AttributeEqualityPredicate(ctx._term.name, ctx._term.value);
        }
        else if (!!ctx._term.position) {
            return new predicates_1.PositionPredicate(ctx._term.position);
        }
        else if (!!ctx._term.locationSteps) {
            return new predicates_1.NestedPathExpressionPredicate(ctx._term);
        }
        else if (!!ctx._term.functionName) {
            return new FunctionPredicate_1.FunctionPredicate(ctx._term.functionName);
        }
        throw new Error(`Unsupported predicate: ${JSON.stringify(ctx._term)}`);
    },
    _rb: "]",
    $lazy: true,
};
const PredicateGrammar = Concat_1.Concat.of(PredicateGrammarDefs);
const NodeTestGrammar = {
    _it: Ops_1.firstOf("*", NodeName),
    test: ctx => ctx._it === "*" ? nodeTests_1.AllNodeTest : new nodeTests_1.NamedNodeTest(ctx._it),
};
const LocationStepGrammar = Microgrammar_1.Microgrammar.fromDefinitions({
    _axis: Ops_1.optional(Ops_1.firstOf("/", "..", ".", /[a-z\-]+::/)),
    axis: ctx => {
        switch (ctx._axis) {
            case undefined:
                return axisSpecifiers_1.ChildAxisSpecifier;
            case "/":
                return axisSpecifiers_1.DescendantOrSelfAxisSpecifier;
            case ".":
                return axisSpecifiers_1.SelfAxisSpecifier;
            case "..":
                return axisSpecifiers_1.ParentAxisSpecifier;
            default:
                // Full syntax, not abbreviated
                if (ctx._axis.endsWith("::")) {
                    const specifier = ctx._axis.substr(0, ctx._axis.length - 2);
                    switch (specifier) {
                        case axisSpecifiers_1.AncestorAxisSpecifier.type:
                            return axisSpecifiers_1.AncestorAxisSpecifier;
                        case axisSpecifiers_1.AncestorOrSelfAxisSpecifier.type:
                            return axisSpecifiers_1.AncestorOrSelfAxisSpecifier;
                        case axisSpecifiers_1.ChildAxisSpecifier.type:
                            return axisSpecifiers_1.ChildAxisSpecifier;
                        case axisSpecifiers_1.DescendantAxisSpecifier.type:
                            return axisSpecifiers_1.DescendantAxisSpecifier;
                        case axisSpecifiers_1.DescendantOrSelfAxisSpecifier.type:
                            return axisSpecifiers_1.DescendantOrSelfAxisSpecifier;
                        case axisSpecifiers_1.FollowingSiblingAxisSpecifier.type:
                            return axisSpecifiers_1.FollowingSiblingAxisSpecifier;
                        case axisSpecifiers_1.ParentAxisSpecifier.type:
                            return axisSpecifiers_1.ParentAxisSpecifier;
                        case axisSpecifiers_1.PrecedingSiblingAxisSpecifier.type:
                            return axisSpecifiers_1.PrecedingSiblingAxisSpecifier;
                        case axisSpecifiers_1.SelfAxisSpecifier.type:
                            return axisSpecifiers_1.SelfAxisSpecifier;
                    }
                }
                throw new Error(`Unsupported axis specifier [${ctx._axis}]`);
        }
    },
    _test: Ops_1.optional(NodeTestGrammar),
    // It's valid to omit the node test only with these axis specifiers
    _validate: ctx => ctx._test || [axisSpecifiers_1.ParentAxisSpecifier, axisSpecifiers_1.SelfAxisSpecifier].includes(ctx.axis),
    test: ctx => !!ctx._test ? ctx._test.test : nodeTests_1.AllNodeTest,
    _predicates: Rep_1.zeroOrMore(PredicateGrammar),
    predicates: ctx => ctx._predicates.map(p => p.term),
});
const RelativePathExpressionDefs = {
    _locationSteps: new Rep_1.Rep1Sep(LocationStepGrammar, "/"),
    locationSteps: ctx => ctx._locationSteps.map(l => new pathExpression_1.LocationStep(l.axis, l.test, l.predicates)),
};
const SimplePathExpressionGrammarDefs = Object.assign({ _slash: Ops_1.optional("/"), absolute: ctx => !!ctx._slash }, RelativePathExpressionDefs);
const PathExpressionGrammar = Microgrammar_1.Microgrammar.fromDefinitions({
    _underlying: new Rep_1.RepSep(SimplePathExpressionGrammarDefs, "|"),
    pathExpression: ctx => ctx._underlying.length > 1 ?
        { unions: ctx._underlying } :
        ctx._underlying[0],
});
//# sourceMappingURL=pathExpressionParser.js.map