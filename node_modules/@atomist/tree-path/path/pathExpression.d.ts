import { TreeNode } from "../TreeNode";
import { ExpressionEngine } from "./expressionEngine";
/**
 * One of the three core elements of a LocationStep. Borrowed from XPath.
 * Determines the kind of navigation.
 */
export interface AxisSpecifier {
    type: string;
    /**
     * Follow the given axis.
     * @param {TreeNode} tn node we're navigating from
     * @param {TreeNode} root root of document. Necessary to handle parent etc.
     * @return {TreeNode[]}
     */
    follow(tn: TreeNode, root: TreeNode): TreeNode[];
}
export declare type FailureResult = string;
export declare type SuccessResult = TreeNode[];
/**
 * Result of executing a path expression
 */
export declare type ExecutionResult = FailureResult | SuccessResult;
export declare function isSuccessResult(a: any): a is SuccessResult;
export declare function isFailureResult(a: any): a is FailureResult;
/**
 * One of the three core elements of a LocationStep. Inspired by XPath NodeTest.
 */
export interface NodeTest {
    /**
     * Test nodes returned from navigating an AxisSpecifier.
     * @param {TreeNode} tn
     * @param {ExpressionEngine} ee
     * @return {SuccessResult}
     */
    test(tn: TreeNode, ee: ExpressionEngine): boolean;
}
/**
 * Signature of a predicate test.
 */
export declare type PredicateTest = (nodeToTest: TreeNode, returnedNodes: TreeNode[], ee: ExpressionEngine, functionRegistry: object) => boolean;
/**
 * Based on the XPath concept of a predicate. A predicate acts on a sequence of nodes
 * returned from navigation to filter them.
 */
export interface Predicate {
    /**
     * Function taking nodes returned by navigation
     * to filter them. We test one node with knowledge of all returned nodes.
     *
     * @param nodeToTest    node we're testing on;
     * @param returnedNodes all nodes returned. This argument is
     *                      often ignored, but can be used to discern the index of the target node.
     * @param ee expression engine to evaluateExpression
     * @param functionRegistry registry to use to look up functions
     */
    evaluate: PredicateTest;
}
/**
 * Step within a path expression
 */
export declare class LocationStep {
    axis: AxisSpecifier;
    test: NodeTest;
    predicates: Predicate[];
    constructor(axis: AxisSpecifier, test: NodeTest, predicates: Predicate[]);
    follow(tn: TreeNode, root: TreeNode, ee: ExpressionEngine, functionRegistry?: object): ExecutionResult;
    toString(): string;
}
/**
 * Result of parsing a path expression.
 */
export interface SimplePathExpression {
    locationSteps: LocationStep[];
}
export interface UnionPathExpression {
    unions: PathExpression[];
}
export declare type PathExpression = SimplePathExpression | UnionPathExpression;
export declare function isUnionPathExpression(pe: PathExpression): pe is UnionPathExpression;
/**
 * Create a Union path expression from the given array of strings or PathExpression
 * instances
 * @param {Array<string | PathExpression>} pathExpressions
 * @return {UnionPathExpression}
 */
export declare function unionOf(pathExpressions: Array<string | PathExpression>): UnionPathExpression;
/**
 * Return an informative string representation of the given path expression
 * @param {PathExpression} pe
 * @return {string}
 */
export declare function stringify(pe: PathExpression): string;
