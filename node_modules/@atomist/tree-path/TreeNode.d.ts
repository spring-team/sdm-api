/**
 * Core abstraction supporting path expressions.
 * Represents a tree node. Property and function names begin with $
 * to ensure they're out of band if we mix in user data.
 * TreeNode instances may be parsed from text input, in which case
 * they will have offsets within the input.
 * NB: If you need to JSON stringify TreeNode instances,
 * use the treeNodeReplacer function or DefaultTreeReplacer constant
 * to avoid circularity errors.
 */
export interface TreeNode {
    readonly $name: string;
    /**
     * Used to evaluate ancestor and other such predicates efficiently.
     * If not available, backup resolution will attempt to navigate from
     * document root if available.
     */
    $parent?: TreeNode;
    /**
     * Children of the node if it's a non-terminal
     */
    $children?: TreeNode[];
    /**
     * Value. If this is a terminal node, its own value, which will always be available.
     * If it's a non-terminal, the value is not guaranteed to be available.
     * If it is, it will be the text from the offset to the end of the
     * last token. This preserves white space between non-terminals.
     */
    $value?: string;
    /** Offset from 0 in the file, if available */
    readonly $offset?: number;
}
export declare function isTerminal(tn: TreeNode): boolean;
/**
 * Replacer to safely stringify nodes, avoiding circularity errors
 * @params keep: Property names to include. Allows us to include
 * node-specific data. By default includes all array elements and
 * name, children, value and offset.
 * @constructor
 */
export declare function treeNodeReplacer(...keep: string[]): (key: string, value: any) => any;
/**
 * Default replacer to use to safely stringify tree nodes
 * @type {(key: string, value: any) => any}
 */
export declare const DefaultTreeNodeReplacer: (key: string, value: any) => any;
