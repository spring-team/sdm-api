import { InputState } from "../InputState";
import { LazyMatchingLogic, Matcher, MatchingLogic, Term } from "../Matchers";
import { MatchPrefixResult } from "../MatchPrefixResult";
import { SkipCapable, WhiteSpaceHandler } from "../Config";
/**
 * Represents something that can be passed into a microgrammar
 */
export declare type TermDef = Term | string | RegExp;
export interface MatchVeto {
    $id: string;
    veto: ((ctx: {}, thisMatchContext: {}, parseContext: {}) => boolean);
}
export interface ContextComputation {
    $id: string;
    compute: ((ctx: {}) => any);
}
/**
 * Represents a step during matching. Can be a matcher or a function,
 * that can work on the context and return a fresh value.
 */
export declare type MatchStep = Matcher | MatchVeto | ContextComputation;
/**
 * Represents a concatenation of multiple matchers. This is the normal
 * way we compose matches, although this class needn't be used explicitly,
 * as Microgrammars use it, via fromDefinitions or by composition involving
 * an object literal which will be converted to a Concat.
 * Users should only create Concats directly in the unusual case where they need
 * to control whitespace handling in a unique way for that particular Concat.
 */
export declare class Concat implements LazyMatchingLogic, WhiteSpaceHandler, SkipCapable {
    definitions: any;
    /**
     * Normal way to create a Concat. If a $lazy field
     * is set to true, the Concat will be lazily initialized, and
     * _init() must be called before use.
     * @param definitions
     * @return {Concat}
     */
    static of(definitions: any): Concat;
    $consumeWhiteSpaceBetweenTokens: boolean;
    $skipGaps: boolean;
    $lazy: boolean;
    readonly matchSteps: MatchStep[];
    private firstMatcher;
    private constructor();
    /**
     * Evaluate all members to ready this Concat for use.
     * Only call this function after using the lazy static factory method:
     * _init is called automatically in the case of the regular Concat.of
     * function
     */
    _init(): void;
    readonly $id: any;
    canStartWith(char: string): boolean;
    readonly requiredPrefix: string;
    matchPrefix(initialInputState: InputState, thisMatchContext: any, parseContext: any): MatchPrefixResult;
}
/**
 * Turns a JSON element such as name: "literal" into a matcher.
 * Return undefined if the object is undefined or null
 * @param o object to attempt to make into a matcher
 * @returns {any}
 */
export declare function toMatchingLogic(o: TermDef): MatchingLogic;
/**
 * Give an existing matcher a name
 */
export declare class NamedMatcher implements Matcher {
    name: string;
    ml: MatchingLogic;
    $id: string;
    constructor(name: string, ml: MatchingLogic);
    matchPrefix(is: InputState, thisMatchContext: any, parseContext: any): MatchPrefixResult;
    canStartWith(char: string): boolean;
    readonly requiredPrefix: string;
}
export declare function isNamedMatcher(thing: MatchingLogic): thing is NamedMatcher;
