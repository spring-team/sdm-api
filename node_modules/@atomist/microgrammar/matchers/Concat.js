"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MatchPrefixResult_1 = require("../MatchPrefixResult");
var PatternMatch_1 = require("../PatternMatch");
var Primitives_1 = require("../Primitives");
var Break_1 = require("../internal/Break");
var Whitespace_1 = require("../internal/Whitespace");
function isMatchVeto(thing) {
    return PatternMatch_1.isSpecialMember(thing.$id);
}
var methodsOnEveryMatchingLogic = ["$id", "matchPrefix", "canStartWith", "requiredPrefix"];
/**
 * Represents a concatenation of multiple matchers. This is the normal
 * way we compose matches, although this class needn't be used explicitly,
 * as Microgrammars use it, via fromDefinitions or by composition involving
 * an object literal which will be converted to a Concat.
 * Users should only create Concats directly in the unusual case where they need
 * to control whitespace handling in a unique way for that particular Concat.
 */
var Concat = /** @class */ (function () {
    function Concat(definitions) {
        this.definitions = definitions;
        this.$consumeWhiteSpaceBetweenTokens = true;
        this.$skipGaps = false;
        this.$lazy = false;
        this.matchSteps = [];
    }
    /**
     * Normal way to create a Concat. If a $lazy field
     * is set to true, the Concat will be lazily initialized, and
     * _init() must be called before use.
     * @param definitions
     * @return {Concat}
     */
    Concat.of = function (definitions) {
        var concat = new Concat(definitions);
        if (definitions.$lazy !== true) {
            concat._init();
        }
        return concat;
    };
    /**
     * Evaluate all members to ready this Concat for use.
     * Only call this function after using the lazy static factory method:
     * _init is called automatically in the case of the regular Concat.of
     * function
     */
    Concat.prototype._init = function () {
        for (var stepName in this.definitions) {
            if (methodsOnEveryMatchingLogic.indexOf(stepName) === -1) {
                var def = this.definitions[stepName];
                if (def === undefined || def === null) {
                    throw new Error("Invalid concatenation: Step [" + stepName + "] is " + def);
                }
                if (stepName.charAt(0) === "$") {
                    // It's a config property. Copy it over.
                    this[stepName] = def;
                }
                else if (typeof def === "function") {
                    // It's a calculation function
                    if (def.length === 0 && stepName !== "_init") {
                        // A no arg function is invalid
                        throw new Error("No arg function [" + stepName + "] is invalid as a matching step");
                    }
                    if (PatternMatch_1.isSpecialMember(stepName)) {
                        this.matchSteps.push({ $id: stepName, veto: def });
                    }
                    else {
                        this.matchSteps.push({ $id: stepName, compute: def });
                    }
                }
                else {
                    // It's a normal matcher
                    var m = toMatchingLogic(def);
                    // If we are skipping gaps, skip between productions
                    var named = new NamedMatcher(stepName, this.$skipGaps === true ? new Break_1.Break(m, true) : m);
                    this.matchSteps.push(named);
                }
            }
        }
        this.firstMatcher = this.matchSteps.filter(function (s) { return isMatcher(s); })[0];
    };
    Object.defineProperty(Concat.prototype, "$id", {
        get: function () {
            return (this.definitions.$id) ?
                this.definitions.$id :
                "Concat{" + this.matchSteps.map(function (m) { return m.$id; }).join(",") + "}";
        },
        enumerable: true,
        configurable: true
    });
    Concat.prototype.canStartWith = function (char) {
        return !this.firstMatcher.canStartWith || this.firstMatcher.canStartWith(char);
    };
    Object.defineProperty(Concat.prototype, "requiredPrefix", {
        get: function () {
            return this.firstMatcher.requiredPrefix;
        },
        enumerable: true,
        configurable: true
    });
    Concat.prototype.matchPrefix = function (initialInputState, thisMatchContext, parseContext) {
        var bindingTarget = {};
        var matches = [];
        var currentInputState = initialInputState;
        var matched = "";
        for (var _i = 0, _a = this.matchSteps; _i < _a.length; _i++) {
            var step = _a[_i];
            if (isMatcher(step)) {
                var eat = Whitespace_1.readyToMatch(currentInputState, this.$consumeWhiteSpaceBetweenTokens);
                currentInputState = eat.state;
                matched += eat.skipped;
                var reportResult = step.matchPrefix(currentInputState, thisMatchContext, parseContext);
                if (MatchPrefixResult_1.isSuccessfulMatch(reportResult)) {
                    var report = reportResult.match;
                    matches.push(report);
                    currentInputState = currentInputState.consume(report.$matched, "Concat step [" + reportResult.$matcherId + "] matched " + reportResult.$matched);
                    matched += report.$matched;
                    if (reportResult.capturedStructure) {
                        // Bind the nested structure if necessary
                        bindingTarget[step.$id] = reportResult.capturedStructure;
                    }
                    else {
                        // otherwise, save the matcher's value.
                        bindingTarget[step.$id] = report.$value;
                    }
                }
                else {
                    return new MatchPrefixResult_1.MatchFailureReport(this.$id, initialInputState.offset, bindingTarget, "Failed at step '" + step.name + "' due to " + reportResult.description);
                }
            }
            else {
                // It's a function taking the contexts.
                // See if we should stop matching.
                if (isMatchVeto(step)) {
                    if (step.veto(bindingTarget, thisMatchContext, parseContext) === false) {
                        return new MatchPrefixResult_1.MatchFailureReport(this.$id, initialInputState.offset, bindingTarget, "Match vetoed by " + step.$id);
                    }
                }
                else {
                    bindingTarget[step.$id] = step.compute(bindingTarget);
                }
            }
        }
        return MatchPrefixResult_1.matchPrefixSuccess(new PatternMatch_1.TreePatternMatch(this.$id, matched, initialInputState.offset, this.matchSteps.filter(function (m) { return m.matchPrefix; }), matches, bindingTarget), bindingTarget);
    };
    return Concat;
}());
exports.Concat = Concat;
function isMatcher(s) {
    return s.matchPrefix !== undefined;
}
/**
 * Turns a JSON element such as name: "literal" into a matcher.
 * Return undefined if the object is undefined or null
 * @param o object to attempt to make into a matcher
 * @returns {any}
 */
function toMatchingLogic(o) {
    if (!o) {
        return undefined;
    }
    if (typeof o === "string") {
        return new Primitives_1.Literal(o);
    }
    else if (o.exec) {
        return new Primitives_1.Regex(o);
    }
    else if (o.matchPrefix) {
        return o;
    }
    else if (o.findMatches) {
        return o.matcher;
    }
    else {
        return Concat.of(o);
    }
}
exports.toMatchingLogic = toMatchingLogic;
/**
 * Give an existing matcher a name
 */
var NamedMatcher = /** @class */ (function () {
    function NamedMatcher(name, ml) {
        this.name = name;
        this.ml = ml;
        this.$id = this.name;
    }
    NamedMatcher.prototype.matchPrefix = function (is, thisMatchContext, parseContext) {
        return this.ml.matchPrefix(is, thisMatchContext, parseContext);
    };
    NamedMatcher.prototype.canStartWith = function (char) {
        return !this.ml.canStartWith || this.ml.canStartWith(char);
    };
    Object.defineProperty(NamedMatcher.prototype, "requiredPrefix", {
        get: function () {
            return this.ml.requiredPrefix;
        },
        enumerable: true,
        configurable: true
    });
    return NamedMatcher;
}());
exports.NamedMatcher = NamedMatcher;
function isNamedMatcher(thing) {
    return (thing.name !== undefined) && thing.ml !== undefined;
}
exports.isNamedMatcher = isNamedMatcher;
//# sourceMappingURL=Concat.js.map