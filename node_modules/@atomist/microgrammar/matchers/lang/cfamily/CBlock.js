"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var InputStateFactory_1 = require("../../../internal/InputStateFactory");
var MatchPrefixResult_1 = require("../../../MatchPrefixResult");
var PatternMatch_1 = require("../../../PatternMatch");
var Concat_1 = require("../../Concat");
var CFamilyStateMachine_1 = require("./CFamilyStateMachine");
/**
 * The rest of a C family block, going to a matching depth of +1 curlies or braces.
 * Does not read final curly
 */
var CBlock = /** @class */ (function () {
    function CBlock(stateMachineFactory, kind, inner) {
        this.stateMachineFactory = stateMachineFactory;
        this.kind = kind;
        this.inner = inner;
        switch (kind) {
            case "block":
                _a = ["{", "}"], this.push = _a[0], this.pop = _a[1];
                break;
            case "parens":
                _b = ["(", ")"], this.push = _b[0], this.pop = _b[1];
                break;
        }
        var _a, _b;
    }
    CBlock.prototype.matchPrefix = function (is, thisMatchContext, parseContext) {
        var sm = this.stateMachineFactory();
        var depth = 1;
        var currentIs = is;
        var matched = "";
        while (depth > 0) {
            var next = currentIs.peek(1);
            if (next.length === 0) {
                break;
            }
            sm.consume(next);
            if (sm.state.normal()) {
                switch (next) {
                    case this.push:
                        depth++;
                        break;
                    case this.pop:
                        depth--;
                        break;
                    default:
                }
            }
            if (depth > 0) {
                matched += next;
                currentIs = currentIs.advance();
            }
        }
        if (!this.inner) {
            return MatchPrefixResult_1.matchPrefixSuccess(new PatternMatch_1.TerminalPatternMatch(this.$id, matched, is.offset, matched));
        }
        // We supply the offset to preserve it in this match
        return this.inner.matchPrefix(InputStateFactory_1.inputStateFromString(matched, undefined, is.offset), thisMatchContext, parseContext);
    };
    return CBlock;
}());
exports.CBlock = CBlock;
/**
 * Match a block with balanced curlies
 * @type {Term}
 */
function block(stateMachineFactory) {
    return Concat_1.Concat.of({
        $id: "{...}",
        _lp: "{",
        block: new CBlock(stateMachineFactory, "block"),
        _rp: "}",
    });
}
exports.block = block;
function blockContaining(m, stateMachineFactory) {
    if (stateMachineFactory === void 0) { stateMachineFactory = function () { return new CFamilyStateMachine_1.CFamilyStateMachine(); }; }
    return Concat_1.Concat.of({
        $id: "{...}",
        _lp: "{",
        block: new CBlock(stateMachineFactory, "block", m),
        _rp: "}",
    });
}
exports.blockContaining = blockContaining;
/**
 * Match a parenthesized expression including ()
 * @type {Concat}
 */
function parenthesizedExpression(stateMachineFactory) {
    if (stateMachineFactory === void 0) { stateMachineFactory = function () { return new CFamilyStateMachine_1.CFamilyStateMachine(); }; }
    return Concat_1.Concat.of({
        $id: "(...)",
        _lp: "(",
        block: new CBlock(stateMachineFactory, "parens"),
        _rp: ")",
    });
}
exports.parenthesizedExpression = parenthesizedExpression;
//# sourceMappingURL=CBlock.js.map