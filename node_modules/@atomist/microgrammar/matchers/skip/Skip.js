"use strict";
/**
 * Convenient operations to skip over input
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Break_1 = require("../../internal/Break");
var MatchPrefixResult_1 = require("../../MatchPrefixResult");
var PatternMatch_1 = require("../../PatternMatch");
var Primitives_1 = require("../../Primitives");
var Concat_1 = require("../Concat");
/**
 * Match the rest of the input.
 */
exports.RestOfInput = {
    $id: "RestOfInput",
    matchPrefix: function (is) {
        var consumed = is.skipWhile(function (s) { return true; }, 1);
        return MatchPrefixResult_1.matchPrefixSuccess(new PatternMatch_1.TerminalPatternMatch(this.$id, consumed.skipped, is.offset, consumed.skipped));
    },
};
/**
 * Match the rest of the current line
 */
exports.RestOfLine = new Break_1.Break(new Primitives_1.Literal("\n"));
/**
 * Match a string until the given matcher. Wraps Break.
 * Binds the content until the break.
 */
function takeUntil(what) {
    return new Break_1.Break(Concat_1.toMatchingLogic(what));
}
exports.takeUntil = takeUntil;
/**
 * Skip all content until the given matcher. Bind its match
 */
function skipTo(what) {
    return new Break_1.Break(Concat_1.toMatchingLogic(what), true);
}
exports.skipTo = skipTo;
/**
 * Return a match for the first thing if it doesn't
 * @param a desired match
 * @param b match we don't want.
 */
function yadaYadaThenThisButNotThat(a, b) {
    return new Break_1.Break(Concat_1.toMatchingLogic(a), true, Concat_1.toMatchingLogic(b));
}
exports.yadaYadaThenThisButNotThat = yadaYadaThenThisButNotThat;
/**
 * Anything, then the given matcher. Binds the terminal match
 * @param a desired match
 * @returns {Break}
 */
function yadaYadaThen(a) {
    return new Break_1.Break(Concat_1.toMatchingLogic(a), true);
}
exports.yadaYadaThen = yadaYadaThen;
//# sourceMappingURL=Skip.js.map