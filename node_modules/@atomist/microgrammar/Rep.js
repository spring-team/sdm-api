"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Concat_1 = require("./matchers/Concat");
var MatchPrefixResult_1 = require("./MatchPrefixResult");
var PatternMatch_1 = require("./PatternMatch");
var Whitespace_1 = require("./internal/Whitespace");
/**
 * Match zero or more of these
 * @param o matcher
 * @return {Rep1}
 */
function zeroOrMore(o) {
    return new Rep(o);
}
exports.zeroOrMore = zeroOrMore;
/**
 * Match at least one of these
 * @param o matcher
 * @return {Rep1}
 */
function atLeastOne(o) {
    return new Rep1(o);
}
exports.atLeastOne = atLeastOne;
/**
 * Handle repetition, with or without a separator.
 * Prefer subclasses for simplicity and clarity.
 * By default, match zero or more times without a separator
 */
var Repetition = /** @class */ (function () {
    /**
     * Generic rep support. Normally use subclasses.
     * @param o matcher
     * @param min mininum number of times the matcher must match for this to be considered a match. Default 0
     * @param sep if this is provided it indicates that this is a rep sep and it is the delimiter
     */
    function Repetition(o, min, sep) {
        if (min === void 0) { min = 0; }
        this.min = min;
        this.sep = sep;
        this.$consumeWhiteSpaceBetweenTokens = true;
        this.matcher = Concat_1.toMatchingLogic(o);
        if (sep) {
            this.sepMatcher = Concat_1.toMatchingLogic(sep);
        }
    }
    Object.defineProperty(Repetition.prototype, "$id", {
        get: function () {
            return "Rep[" + this.matcher + ":min=" + this.min + ",sep=[" + this.sep + "]";
        },
        enumerable: true,
        configurable: true
    });
    Repetition.prototype.consumeWhiteSpace = function (consumeWhiteSpaceBetweenTokens) {
        this.$consumeWhiteSpaceBetweenTokens = consumeWhiteSpaceBetweenTokens;
        return this;
    };
    Repetition.prototype.canStartWith = function (char) {
        return (this.min === 0) ?
            true :
            !this.matcher.canStartWith || this.matcher.canStartWith(char);
    };
    Object.defineProperty(Repetition.prototype, "requiredPrefix", {
        get: function () {
            return (this.min === 0) ?
                undefined :
                this.matcher.requiredPrefix;
        },
        enumerable: true,
        configurable: true
    });
    Repetition.prototype.matchPrefix = function (is, thisMatchContext, parseContext) {
        var currentInputState = is;
        var matches = [];
        var matched = "";
        while (!currentInputState.exhausted()) {
            var eat = Whitespace_1.readyToMatch(currentInputState, this.$consumeWhiteSpaceBetweenTokens);
            currentInputState = eat.state;
            matched += eat.skipped;
            var result = this.matcher.matchPrefix(currentInputState, thisMatchContext, parseContext);
            if (!MatchPrefixResult_1.isSuccessfulMatch(result)) {
                break;
            }
            else {
                var match = result.match;
                if (match.$matched === "") {
                    throw new Error("Matcher with id " + this.matcher.$id + " within rep matched the empty string.\n" +
                        "I do not think this grammar means what you think it means");
                }
                currentInputState = currentInputState.consume(match.$matched, "Rep matched [" + match.$matched + "]");
                matches.push(match);
                matched += match.$matched;
            }
            if (this.sepMatcher) {
                var eaten = Whitespace_1.readyToMatch(currentInputState, this.$consumeWhiteSpaceBetweenTokens);
                currentInputState = eaten.state;
                matched += eaten.skipped;
                var sepMatchResult = this.sepMatcher.matchPrefix(currentInputState, thisMatchContext, parseContext);
                if (MatchPrefixResult_1.isSuccessfulMatch(sepMatchResult)) {
                    var sepMatch = sepMatchResult.match;
                    currentInputState = currentInputState.consume(sepMatch.$matched, "Rep separator [" + sepMatch.$matched + "]");
                    matched += sepMatch.$matched;
                }
                else {
                    break;
                }
            }
        }
        var values = matches.map(function (m) {
            return (typeof m.$value === "object") ?
                m :
                m.$value;
        });
        return (matches.length >= this.min) ?
            MatchPrefixResult_1.matchPrefixSuccess(new PatternMatch_1.TerminalPatternMatch(this.$id, matched, is.offset, values)) :
            new MatchPrefixResult_1.MatchFailureReport(this.$id, is.offset, {});
    };
    return Repetition;
}());
exports.Repetition = Repetition;
/**
 * Match 0 or more times, without a separator
 */
var Rep = /** @class */ (function (_super) {
    __extends(Rep, _super);
    function Rep(o) {
        return _super.call(this, o, 0) || this;
    }
    return Rep;
}(Repetition));
exports.Rep = Rep;
/**
 * Match 1 or more times
 */
var Rep1 = /** @class */ (function (_super) {
    __extends(Rep1, _super);
    function Rep1(o) {
        return _super.call(this, o, 1) || this;
    }
    return Rep1;
}(Repetition));
exports.Rep1 = Rep1;
var RepSep = /** @class */ (function (_super) {
    __extends(RepSep, _super);
    function RepSep(o, sep) {
        return _super.call(this, o, 0, sep) || this;
    }
    return RepSep;
}(Repetition));
exports.RepSep = RepSep;
var Rep1Sep = /** @class */ (function (_super) {
    __extends(Rep1Sep, _super);
    function Rep1Sep(o, sep) {
        return _super.call(this, o, 1, sep) || this;
    }
    return Rep1Sep;
}(Repetition));
exports.Rep1Sep = Rep1Sep;
//# sourceMappingURL=Rep.js.map