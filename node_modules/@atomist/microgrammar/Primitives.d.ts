import { InputState } from "./InputState";
import { MatchingLogic } from "./Matchers";
import { MatchPrefixResult } from "./MatchPrefixResult";
/**
 * Match a literal string
 */
export declare class Literal implements MatchingLogic {
    literal: string;
    $id: string;
    constructor(literal: string);
    matchPrefix(is: InputState): MatchPrefixResult;
    canStartWith(char: string): boolean;
    readonly requiredPrefix: string;
}
export declare function isLiteral(ml: MatchingLogic): ml is Literal;
/**
 * Support for regex matching. Subclasses can convert the value to
 * whatever type they require.
 */
export declare abstract class AbstractRegex implements MatchingLogic {
    private lookahead;
    readonly regex: RegExp;
    readonly $id: string;
    /**
     * Match a regular expression
     * @param regex JavaScript regex to match. Don't use an end anchor.
     * Start anchor will be added if not already there
     * @param lookahead number of characters to pull from the input to try to match.
     * We'll keep grabbing more if a match is found for the whole string
     */
    constructor(regex: RegExp, lookahead?: number);
    matchPrefix(is: InputState): MatchPrefixResult;
    /**
     * Subclasses will override this to convert the string value from a successful
     * match to any type they require. This enables safe creation of custom types.
     * @param s raw string resulting from a successful match
     */
    protected abstract toValue(s: string): any;
}
/**
 * Match a regular expression.
 */
export declare class Regex extends AbstractRegex {
    /**
     * Create wrapping a native JavaScript regular expression
     * @param regex Regular expression to wrap.
     * Do not use an end anchor. If a start anchor isn't provided it will be added
     */
    constructor(regex: RegExp);
    protected toValue(s: string): string;
}
export declare class MatchInteger extends AbstractRegex {
    constructor();
    canStartWith(c: string): boolean;
    protected toValue(s: string): number;
}
/**
 * Match an integer. Allows 0  but not leading 0 if more digits
 */
export declare const Integer: MatchInteger;
export declare class MatchFloat extends AbstractRegex {
    constructor();
    protected toValue(s: string): number;
}
/**
 * Match a float.
 */
export declare const Float: MatchFloat;
export declare class MatchLowercaseBoolean extends AbstractRegex {
    constructor();
    protected toValue(s: string): boolean;
}
/**
 * Match a LowercaseBoolean.
 */
export declare const LowercaseBoolean: MatchLowercaseBoolean;
