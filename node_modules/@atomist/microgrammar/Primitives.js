"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var MatchPrefixResult_1 = require("./MatchPrefixResult");
var PatternMatch_1 = require("./PatternMatch");
/**
 * Match a literal string
 */
var Literal = /** @class */ (function () {
    function Literal(literal) {
        this.literal = literal;
        this.$id = "Literal[" + this.literal + "]";
    }
    Literal.prototype.matchPrefix = function (is) {
        var peek = is.peek(this.literal.length);
        return (peek === this.literal) ?
            MatchPrefixResult_1.matchPrefixSuccess(new PatternMatch_1.TerminalPatternMatch(this.$id, this.literal, is.offset, this.literal)) :
            new MatchPrefixResult_1.MatchFailureReport(this.$id, is.offset, {}, "Did not match literal [" + this.literal + "]: saw [" + peek + "]");
    };
    Literal.prototype.canStartWith = function (char) {
        return this.literal[0] === char;
    };
    Object.defineProperty(Literal.prototype, "requiredPrefix", {
        get: function () {
            return this.literal;
        },
        enumerable: true,
        configurable: true
    });
    return Literal;
}());
exports.Literal = Literal;
function isLiteral(ml) {
    return ml && ml.literal !== undefined;
}
exports.isLiteral = isLiteral;
var LOOK_AHEAD_SIZE = 100;
/**
 * Support for regex matching. Subclasses can convert the value to
 * whatever type they require.
 */
var AbstractRegex = /** @class */ (function () {
    /**
     * Match a regular expression
     * @param regex JavaScript regex to match. Don't use an end anchor.
     * Start anchor will be added if not already there
     * @param lookahead number of characters to pull from the input to try to match.
     * We'll keep grabbing more if a match is found for the whole string
     */
    function AbstractRegex(regex, lookahead) {
        if (lookahead === void 0) { lookahead = LOOK_AHEAD_SIZE; }
        this.lookahead = lookahead;
        this.regex = regex.source.charAt(0) !== "^" ? new RegExp("^" + regex.source) : regex;
    }
    Object.defineProperty(AbstractRegex.prototype, "$id", {
        get: function () {
            return "Regex: " + this.regex.source;
        },
        enumerable: true,
        configurable: true
    });
    AbstractRegex.prototype.matchPrefix = function (is) {
        var results;
        var lookAt;
        var charactersToSee = 0;
        function theRegexMatchedSomething() {
            return !!results && !!results[0];
        }
        function matchedEverythingWeLookedAt() {
            return results[0] === lookAt;
        }
        function thereIsMoreToRead() {
            return lookAt.length === charactersToSee;
        }
        // Keep asking for more input if we have matched all of the input in
        // our lookahead buffer
        do {
            charactersToSee += this.lookahead;
            lookAt = is.peek(charactersToSee);
            results = this.regex.exec(lookAt);
        } while (theRegexMatchedSomething() && matchedEverythingWeLookedAt() && thereIsMoreToRead());
        if (theRegexMatchedSomething()) {
            var matched = results[0];
            return MatchPrefixResult_1.matchPrefixSuccess(new PatternMatch_1.TerminalPatternMatch(this.$id, matched, is.offset, this.toValue(matched)));
        }
        else {
            return new MatchPrefixResult_1.MatchFailureReport(this.$id, is.offset, {}, "Did not match regex /" + this.regex.source + "/ in [" + lookAt + "]");
        }
    };
    return AbstractRegex;
}());
exports.AbstractRegex = AbstractRegex;
/**
 * Match a regular expression.
 */
var Regex = /** @class */ (function (_super) {
    __extends(Regex, _super);
    /**
     * Create wrapping a native JavaScript regular expression
     * @param regex Regular expression to wrap.
     * Do not use an end anchor. If a start anchor isn't provided it will be added
     */
    function Regex(regex) {
        return _super.call(this, regex) || this;
    }
    Regex.prototype.toValue = function (s) {
        return s;
    };
    return Regex;
}(AbstractRegex));
exports.Regex = Regex;
var MatchInteger = /** @class */ (function (_super) {
    __extends(MatchInteger, _super);
    function MatchInteger() {
        return _super.call(this, /(?:0|[1-9]\d*)/) || this;
    }
    MatchInteger.prototype.canStartWith = function (c) {
        return !isNaN(+c);
    };
    MatchInteger.prototype.toValue = function (s) {
        return parseInt(s, 10);
    };
    return MatchInteger;
}(AbstractRegex));
exports.MatchInteger = MatchInteger;
/**
 * Match an integer. Allows 0  but not leading 0 if more digits
 */
exports.Integer = new MatchInteger();
var MatchFloat = /** @class */ (function (_super) {
    __extends(MatchFloat, _super);
    function MatchFloat() {
        return _super.call(this, /[+-]?\d*[\.]?\d+/) || this;
    }
    MatchFloat.prototype.toValue = function (s) {
        return parseFloat(s);
    };
    return MatchFloat;
}(AbstractRegex));
exports.MatchFloat = MatchFloat;
/**
 * Match a float.
 */
exports.Float = new MatchFloat();
var MatchLowercaseBoolean = /** @class */ (function (_super) {
    __extends(MatchLowercaseBoolean, _super);
    function MatchLowercaseBoolean() {
        return _super.call(this, /^false|true/) || this;
    }
    MatchLowercaseBoolean.prototype.toValue = function (s) {
        return s === "true";
    };
    return MatchLowercaseBoolean;
}(AbstractRegex));
exports.MatchLowercaseBoolean = MatchLowercaseBoolean;
/**
 * Match a LowercaseBoolean.
 */
exports.LowercaseBoolean = new MatchLowercaseBoolean();
//# sourceMappingURL=Primitives.js.map