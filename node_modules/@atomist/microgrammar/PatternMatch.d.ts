import { Matcher } from "./Matchers";
/**
 * Returned when we failed to match prefix
 */
export interface DismatchReport {
    description: string;
}
/**
 * Represents a successful match. Contains microgrammar information
 * in fields with names beginning with $ and any user-defined fields.
 * To ensure this separation works cleanly, not bind user data to fields beginning with $.
 */
export declare abstract class PatternMatch {
    readonly $matcherId: string;
    $matched: string;
    readonly $offset: number;
    /**
     * Value extracted from matcher.
     * @return the $value that is extracted from this matcher. May be a
     * scalar or an array, or a nested structure. May or not be the
     * same as $matched property.
     */
    abstract $value: any;
    /**
     * Represents a match
     * @param $matcherId id of the matcher that matched
     * @param $matched the actual string content
     * @param $offset offset from 0 in input
     */
    constructor($matcherId: string, $matched: string, $offset: number);
    /**
     * Return just the structure that was matched, throwing away offset and matcher information.
     * This is useful if you want to store PatternMatches after you're done with their internal information.
     */
    matchedStructure<T>(): T;
}
export declare function isPatternMatch(mpr: PatternMatch | DismatchReport): mpr is PatternMatch;
/**
 * Simple pattern pattern. No submatches.
 */
export declare class TerminalPatternMatch extends PatternMatch {
    readonly $value: any;
    constructor(matcherId: string, matched: string, offset: number, $value: any);
}
/**
 * Return when an optional matcher matches
 */
export declare class UndefinedPatternMatch extends PatternMatch {
    $value: any;
    constructor(matcherId: string, offset: number);
}
/**
 * Represents a complex pattern match. Sets properties to expose structure.
 * In the case of string properties, where we can't add provide the whole PatternMatch,
 * we store that in a parallel object $valueMatches
 */
export declare class TreePatternMatch extends PatternMatch {
    readonly $valueMatches: {};
    readonly $value: {};
    constructor(matcherId: string, matched: string, offset: number, matchers: Matcher[], subMatches: PatternMatch[], capturedStructure: {});
    submatches(): {};
}
export declare function isTreePatternMatch(om: PatternMatch): om is TreePatternMatch;
/**
 * Return true if the member has a special meaning,
 * rather than being bound to the context. For example,
 * is a veto function or a private property.
 * @param name member name to test
 * @return {boolean}
 */
export declare function isSpecialMember(name: string): boolean;
