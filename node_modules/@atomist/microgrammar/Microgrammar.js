"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Concat_1 = require("./matchers/Concat");
var MatchPrefixResult_1 = require("./MatchPrefixResult");
var StringInputStream_1 = require("./spi/StringInputStream");
var ChangeSet_1 = require("./internal/ChangeSet");
var DefaultInputState_1 = require("./internal/DefaultInputState");
var ExactMatch_1 = require("./internal/ExactMatch");
var InputStateManager_1 = require("./internal/InputStateManager");
var MicrogrammarSpecParser_1 = require("./internal/MicrogrammarSpecParser");
var MicrogrammarUpdates_1 = require("./internal/MicrogrammarUpdates");
var Whitespace_1 = require("./internal/Whitespace");
/**
 * Holds a set of updatable matches
 */
var Updatable = /** @class */ (function () {
    function Updatable(hits, content) {
        var _this = this;
        var mut = new MicrogrammarUpdates_1.MicrogrammarUpdates();
        this.cs = new ChangeSet_1.ChangeSet(content);
        this.matches = hits.map(function (m) { return mut.updatableMatch(m, _this.cs); });
    }
    Updatable.prototype.updated = function () {
        return this.cs.updated();
    };
    return Updatable;
}());
exports.Updatable = Updatable;
/**
 * Central class for microgrammar usage.
 * Represents a microgrammar that we can use to match input
 * in a string or stream.
 * Modifications are tracked and we can get an updated string
 * afterwards.
 */
var Microgrammar = /** @class */ (function () {
    function Microgrammar(matcher) {
        this.matcher = matcher;
        this.definitions = this.matcher.definitions;
    }
    /**
     * Make this match transparently updatable using property mutation
     * @param match match to make updatable
     * @param content the match is within
     * @return {T&MatchUpdater}
     */
    Microgrammar.updatableMatch = function (match, content) {
        return new MicrogrammarUpdates_1.MicrogrammarUpdates().updatableMatch(match, content);
    };
    /**
     * Make these matches transparently updatable using property mutation
     * @param matches matches
     * @param content content the matches are within
     * @return {Updatable<T>}
     */
    Microgrammar.updatable = function (matches, content) {
        return new Updatable(matches, content);
    };
    Microgrammar.fromDefinitions = function (definitions) {
        return new Microgrammar(Concat_1.Concat.of(definitions));
    };
    Microgrammar.fromString = function (spec, components, options) {
        if (components === void 0) { components = {}; }
        if (options === void 0) { options = {}; }
        return new Microgrammar(new MicrogrammarSpecParser_1.MicrogrammarSpecParser().fromString(spec, components, options));
    };
    /**
     * Convenience method to find matches without the ability to update them
     * @param input
     * @param stopAfterMatch() function that can cause matching to stop after a given match.
     * Often used to stop after one.
     * @param parseContext context for the whole parsing operation
     * @param l listeners observing input characters as they are read
     * @return {PatternMatch[]}
     */
    Microgrammar.prototype.findMatches = function (input, parseContext, l, stopAfterMatch) {
        if (stopAfterMatch === void 0) { stopAfterMatch = function (pm) { return false; }; }
        var lm = new LazyMatcher(this.matcher, stopAfterMatch);
        lm.consume(input, parseContext, l);
        return lm.matches;
    };
    /**
     * Convenient method to find the first match, or null if not found.
     * Stops searching after the first match.
     * @param input
     * @param l listeners observing input characters as they are read
     * @returns {PatternMatch[]}
     */
    Microgrammar.prototype.firstMatch = function (input, l) {
        var found = this.findMatches(input, {}, l, function (pm) { return true; });
        return found.length > 0 ? found[0] : null;
    };
    /**
     * Return a match if it explains the whole of the input.
     * This style of usage is more like a traditional parser,
     * building an AST for a whole file.
     * @param input
     * @param parseContext context for the whole parsing operation
     * @param l listeners observing input characters as they are read
     * @return {PatternMatch&T}
     */
    Microgrammar.prototype.exactMatch = function (input, parseContext, l) {
        if (parseContext === void 0) { parseContext = {}; }
        return ExactMatch_1.exactMatch(this.matcher, input, parseContext, l);
    };
    return Microgrammar;
}());
exports.Microgrammar = Microgrammar;
/**
 * Single use, usually stateful, class for matching input.
 * Offers the ability to observe a match, as well as match one,
 * and to change the matcher in use depending on observation and matching.
 * E.g. it's possible to choose to start matching pattern B after finding pattern A,
 * or after *seeing* pattern A, even if starting off matching something else.
 * This enables us, for example, to parse XML, with the observer watching element
 * open and close to maintain the current path, while the matcher matches anything we want.
 */
var MatchingMachine = /** @class */ (function () {
    /**
     * Create a new stateful matching machine
     * @param initialMatcher matcher to start using. This can be changed by the callback methods in this class
     * @param o optional observer
     */
    function MatchingMachine(initialMatcher, o) {
        this.matcher = Concat_1.toMatchingLogic(initialMatcher);
        if (o) {
            this.observer = Concat_1.toMatchingLogic(o);
        }
    }
    /**
     * Stream-oriented matching. The observer can match in parallel with the main matcher.
     * @param input
     * @param parseContext context for the whole parsing operation
     * @param l listeners observing input characters as they are read
     */
    MatchingMachine.prototype.consume = function (input, parseContext, l) {
        if (parseContext === void 0) { parseContext = {}; }
        var omg = this.observer ? Microgrammar.fromDefinitions(this.observer) : undefined;
        var currentMatcher = this.matcher;
        var stream = toInputStream(input);
        var stateManager = new InputStateManager_1.InputStateManager(stream);
        var currentInputState = new DefaultInputState_1.DefaultInputState(stateManager, 0, l);
        while (currentMatcher && !currentInputState.exhausted()) {
            currentInputState = Whitespace_1.readyToMatch(currentInputState, this.matcher.$consumeWhiteSpaceBetweenTokens === true, currentMatcher, this.observer).state;
            var previousIs = currentInputState;
            var tryMatch = currentMatcher.matchPrefix(currentInputState, {}, parseContext);
            // We can't accept empty matches as genuine at this level:
            // For example, if the matcher is just a Rep or Alt
            if (MatchPrefixResult_1.isSuccessfulMatch(tryMatch) && tryMatch.$matched !== "") {
                var match = tryMatch.match;
                // Enrich with the name
                match.$name = match.$matcherId;
                currentMatcher = Concat_1.toMatchingLogic(this.onMatch(match));
                currentInputState = currentInputState.consume(match.$matched, "Microgrammar after match on [" + match.$matched + " from [" + match.$matcherId + "]");
            }
            else {
                // We didn't match. Discard the current input character and try again
                if (!currentInputState.exhausted()) {
                    currentInputState = currentInputState.advance();
                }
            }
            if (this.observer) {
                // There are two cases: If we matched, we need to look multiple times in the input
                if (MatchPrefixResult_1.isSuccessfulMatch(tryMatch) && omg) {
                    var matches = omg.findMatches(tryMatch.$matched);
                    for (var _i = 0, matches_1 = matches; _i < matches_1.length; _i++) {
                        var m = matches_1[_i];
                        currentMatcher = Concat_1.toMatchingLogic(this.observeMatch(m));
                    }
                }
                else {
                    var observerMatch = this.observer.matchPrefix(previousIs, {}, parseContext);
                    if (MatchPrefixResult_1.isSuccessfulMatch(observerMatch)) {
                        currentMatcher = Concat_1.toMatchingLogic(this.observeMatch(observerMatch.match));
                    }
                }
            }
            // We can advance the window
            stateManager.dropLeft(currentInputState.offset);
        } // while
    };
    /**
     * Observe a match. The return can change the matcher in use, or return the current matcher.
     * @param pm pattern to observe
     * @returns {MatchingLogic}
     */
    MatchingMachine.prototype.observeMatch = function (pm) {
        return this.matcher;
    };
    /**
     * React to a match. The return can change the matcher, or return the current matcher.
     * @param pm matcher
     */
    MatchingMachine.prototype.onMatch = function (pm) {
        return this.matcher;
    };
    return MatchingMachine;
}());
exports.MatchingMachine = MatchingMachine;
function toInputStream(input) {
    return (typeof input === "string") ?
        new StringInputStream_1.StringInputStream(input) :
        input;
}
var LazyMatcher = /** @class */ (function (_super) {
    __extends(LazyMatcher, _super);
    function LazyMatcher(ml, stopAfterMatch) {
        var _this = _super.call(this, ml) || this;
        _this.stopAfterMatch = stopAfterMatch;
        _this.matches = [];
        return _this;
    }
    LazyMatcher.prototype.onMatch = function (pm) {
        this.matches.push(pm);
        return this.stopAfterMatch(pm) ? undefined : this.matcher;
    };
    return LazyMatcher;
}(MatchingMachine));
//# sourceMappingURL=Microgrammar.js.map