import { Listeners } from "./InputState";
import { MatchingLogic, Term } from "./Matchers";
import { Concat } from "./matchers/Concat";
import { DismatchReport, PatternMatch } from "./PatternMatch";
import { InputStream } from "./spi/InputStream";
import { FromStringOptions } from "./FromStringOptions";
import { MatchUpdater } from "./internal/MicrogrammarUpdates";
/**
 * Holds a set of updatable matches
 */
export declare class Updatable<T> {
    readonly matches: T[];
    private cs;
    constructor(hits: Array<T & PatternMatch>, content: string);
    updated(): string;
}
/**
 * Central class for microgrammar usage.
 * Represents a microgrammar that we can use to match input
 * in a string or stream.
 * Modifications are tracked and we can get an updated string
 * afterwards.
 */
export declare class Microgrammar<T> implements Term {
    matcher: Concat;
    /**
     * Make this match transparently updatable using property mutation
     * @param match match to make updatable
     * @param content the match is within
     * @return {T&MatchUpdater}
     */
    static updatableMatch<T>(match: T & PatternMatch, content: string): T & MatchUpdater;
    /**
     * Make these matches transparently updatable using property mutation
     * @param matches matches
     * @param content content the matches are within
     * @return {Updatable<T>}
     */
    static updatable<T>(matches: Array<T & PatternMatch>, content: string): Updatable<T>;
    static fromDefinitions<T>(definitions: {}): Microgrammar<T>;
    static fromString<T>(spec: string, components?: object, options?: FromStringOptions): Microgrammar<T>;
    $id: string;
    definitions: any;
    constructor(matcher: Concat);
    /**
     * Convenience method to find matches without the ability to update them
     * @param input
     * @param stopAfterMatch() function that can cause matching to stop after a given match.
     * Often used to stop after one.
     * @param parseContext context for the whole parsing operation
     * @param l listeners observing input characters as they are read
     * @return {PatternMatch[]}
     */
    findMatches(input: string | InputStream, parseContext?: {}, l?: Listeners, stopAfterMatch?: (pm: PatternMatch) => boolean): Array<T & PatternMatch>;
    /**
     * Convenient method to find the first match, or null if not found.
     * Stops searching after the first match.
     * @param input
     * @param l listeners observing input characters as they are read
     * @returns {PatternMatch[]}
     */
    firstMatch(input: string | InputStream, l?: Listeners): PatternMatch & T | null;
    /**
     * Return a match if it explains the whole of the input.
     * This style of usage is more like a traditional parser,
     * building an AST for a whole file.
     * @param input
     * @param parseContext context for the whole parsing operation
     * @param l listeners observing input characters as they are read
     * @return {PatternMatch&T}
     */
    exactMatch(input: string | InputStream, parseContext?: {}, l?: Listeners): PatternMatch & T | DismatchReport;
}
/**
 * Single use, usually stateful, class for matching input.
 * Offers the ability to observe a match, as well as match one,
 * and to change the matcher in use depending on observation and matching.
 * E.g. it's possible to choose to start matching pattern B after finding pattern A,
 * or after *seeing* pattern A, even if starting off matching something else.
 * This enables us, for example, to parse XML, with the observer watching element
 * open and close to maintain the current path, while the matcher matches anything we want.
 */
export declare abstract class MatchingMachine {
    protected matcher: MatchingLogic;
    protected observer: MatchingLogic;
    /**
     * Create a new stateful matching machine
     * @param initialMatcher matcher to start using. This can be changed by the callback methods in this class
     * @param o optional observer
     */
    constructor(initialMatcher: any, o?: any);
    /**
     * Stream-oriented matching. The observer can match in parallel with the main matcher.
     * @param input
     * @param parseContext context for the whole parsing operation
     * @param l listeners observing input characters as they are read
     */
    consume(input: string | InputStream, parseContext?: {}, l?: Listeners): void;
    /**
     * Observe a match. The return can change the matcher in use, or return the current matcher.
     * @param pm pattern to observe
     * @returns {MatchingLogic}
     */
    protected observeMatch(pm: PatternMatch): any;
    /**
     * React to a match. The return can change the matcher, or return the current matcher.
     * @param pm matcher
     */
    protected onMatch(pm: PatternMatch): any;
}
