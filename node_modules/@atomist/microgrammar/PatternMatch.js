"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represents a successful match. Contains microgrammar information
 * in fields with names beginning with $ and any user-defined fields.
 * To ensure this separation works cleanly, not bind user data to fields beginning with $.
 */
var PatternMatch = /** @class */ (function () {
    /**
     * Represents a match
     * @param $matcherId id of the matcher that matched
     * @param $matched the actual string content
     * @param $offset offset from 0 in input
     */
    function PatternMatch($matcherId, $matched, $offset) {
        this.$matcherId = $matcherId;
        this.$matched = $matched;
        this.$offset = $offset;
    }
    /**
     * Return just the structure that was matched, throwing away offset and matcher information.
     * This is useful if you want to store PatternMatches after you're done with their internal information.
     */
    PatternMatch.prototype.matchedStructure = function () {
        return justTheData(this);
    };
    return PatternMatch;
}());
exports.PatternMatch = PatternMatch;
function isPatternMatch(mpr) {
    return mpr != null && mpr !== undefined && mpr.$matched !== undefined;
}
exports.isPatternMatch = isPatternMatch;
/**
 * Simple pattern pattern. No submatches.
 */
var TerminalPatternMatch = /** @class */ (function (_super) {
    __extends(TerminalPatternMatch, _super);
    function TerminalPatternMatch(matcherId, matched, offset, $value) {
        var _this = _super.call(this, matcherId, matched, offset) || this;
        _this.$value = $value;
        return _this;
    }
    return TerminalPatternMatch;
}(PatternMatch));
exports.TerminalPatternMatch = TerminalPatternMatch;
/**
 * Return when an optional matcher matches
 */
var UndefinedPatternMatch = /** @class */ (function (_super) {
    __extends(UndefinedPatternMatch, _super);
    function UndefinedPatternMatch(matcherId, offset) {
        var _this = _super.call(this, matcherId, "", offset) || this;
        _this.$value = undefined;
        return _this;
    }
    return UndefinedPatternMatch;
}(PatternMatch));
exports.UndefinedPatternMatch = UndefinedPatternMatch;
/**
 * Represents a complex pattern match. Sets properties to expose structure.
 * In the case of string properties, where we can't add provide the whole PatternMatch,
 * we store that in a parallel object $valueMatches
 */
var TreePatternMatch = /** @class */ (function (_super) {
    __extends(TreePatternMatch, _super);
    function TreePatternMatch(matcherId, matched, offset, matchers, subMatches, capturedStructure) {
        var _this = _super.call(this, matcherId, matched, offset) || this;
        // JESS: can we not have a $value
        _this.$valueMatches = {};
        _this.$value = {};
        // Copy top level context properties
        for (var p in capturedStructure) {
            if (!isSpecialMember(p) && typeof capturedStructure[p] !== "function") {
                _this[p] = capturedStructure[p];
            }
        }
        for (var i = 0; i < subMatches.length; i++) {
            var match = subMatches[i];
            var name_1 = matchers[i].name;
            if (!isSpecialMember(name_1)) {
                var value = subMatches[i].$value;
                _this.$value[matchers[i].name] = value;
                if (isTreePatternMatch(match)) {
                    _this[name_1] = match;
                }
                else {
                    // if the context defined it already, let that stand
                    if (_this[name_1] === undefined) {
                        _this[name_1] = value;
                    }
                    // We've got nowhere to put the matching information on a simple value,
                    // so create a parallel property on the parent with an out of band name
                    _this.$valueMatches[matchers[i].name] = subMatches[i];
                }
            }
        }
        return _this;
    }
    TreePatternMatch.prototype.submatches = function () {
        var output = {};
        for (var _i = 0, _a = Object.getOwnPropertyNames(this); _i < _a.length; _i++) {
            var key = _a[_i];
            if (key.charAt(0) !== "$") {
                var value = this[key];
                if (isPatternMatch(value)) {
                    output[key] = value;
                }
                else {
                    output[key] = this.$valueMatches[key];
                }
            }
        }
        return output;
    };
    return TreePatternMatch;
}(PatternMatch));
exports.TreePatternMatch = TreePatternMatch;
function isTreePatternMatch(om) {
    return om != null && om.submatches !== undefined;
}
exports.isTreePatternMatch = isTreePatternMatch;
/**
 * Return true if the member has a special meaning,
 * rather than being bound to the context. For example,
 * is a veto function or a private property.
 * @param name member name to test
 * @return {boolean}
 */
function isSpecialMember(name) {
    return name.indexOf("_") === 0;
}
exports.isSpecialMember = isSpecialMember;
function justTheData(match) {
    if (Array.isArray(match)) {
        return match.map(function (m) { return justTheData(m); });
    }
    if (typeof match !== "object") {
        return match;
    }
    var output = {}; // it is not a const, I mutate it, but tslint won't let me declare otherwise :-(
    for (var p in match) {
        if (!(p.indexOf("_") === 0 || p.indexOf("$") === 0 || typeof match[p] === "function")) {
            output[p] = justTheData(match[p]);
        }
    }
    return output;
}
//# sourceMappingURL=PatternMatch.js.map