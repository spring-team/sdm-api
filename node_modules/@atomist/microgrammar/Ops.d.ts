import { InputState } from "./InputState";
import { MatchingLogic } from "./Matchers";
import { MatchPrefixResult } from "./MatchPrefixResult";
import { PatternMatch } from "./PatternMatch";
/**
 * Optional match on the given matcher
 * @param o matcher
 * @return {Opt}
 */
export declare function optional(o: any): MatchingLogic;
export declare class Opt implements MatchingLogic {
    private matcher;
    /**
     * Optional match
     * @param o matching logic
     */
    constructor(o: any);
    readonly $id: string;
    matchPrefix(is: InputState, thisMatchContext: {}, parseContext: {}): MatchPrefixResult;
}
/**
 * Match the first of these matchers that matches. Equivalent to an Alt (alternate)
 * @param a first matcher
 * @param b second matcher
 * @param matchers any further matchers: varargs
 * @returns {Alt}
 */
export declare function firstOf(a: any, b: any, ...matchers: any[]): MatchingLogic;
/**
 * Matches first match of 2 or more matchers.
 */
export declare class Alt implements MatchingLogic {
    readonly matchers: MatchingLogic[];
    constructor(a: any, b: any, ...matchers: any[]);
    readonly $id: string;
    matchPrefix(is: InputState, thisMatchContext: {}, parseContext: {}): MatchPrefixResult;
}
/**
 * Add a condition with a function that verifies that even if we found a match
 * we are happy with it: For example, we like the value it contains.
 * Also capable of vetoing match if the input state is problematic before the potential match
 */
export declare function when(o: any, matchTest: (pm: PatternMatch) => boolean, inputStateTest?: (is: InputState) => boolean): any;
