"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Concat_1 = require("./matchers/Concat");
var MatchPrefixResult_1 = require("./MatchPrefixResult");
var PatternMatch_1 = require("./PatternMatch");
/**
 * Optional match on the given matcher
 * @param o matcher
 * @return {Opt}
 */
function optional(o) {
    return new Opt(o);
}
exports.optional = optional;
var Opt = /** @class */ (function () {
    /**
     * Optional match
     * @param o matching logic
     */
    function Opt(o) {
        this.matcher = Concat_1.toMatchingLogic(o);
    }
    Object.defineProperty(Opt.prototype, "$id", {
        get: function () {
            return "Opt[" + this.matcher.$id + "]";
        },
        enumerable: true,
        configurable: true
    });
    Opt.prototype.matchPrefix = function (is, thisMatchContext, parseContext) {
        if (is.exhausted()) {
            // console.log(`Match from Opt on exhausted stream`);
            return MatchPrefixResult_1.matchPrefixSuccess(new PatternMatch_1.UndefinedPatternMatch(this.$id, is.offset));
        }
        var maybe = this.matcher.matchPrefix(is, thisMatchContext, parseContext);
        if (MatchPrefixResult_1.isSuccessfulMatch(maybe)) {
            return maybe;
        }
        return MatchPrefixResult_1.matchPrefixSuccess(new PatternMatch_1.UndefinedPatternMatch(this.$id, is.offset));
    };
    return Opt;
}());
exports.Opt = Opt;
/**
 * Match the first of these matchers that matches. Equivalent to an Alt (alternate)
 * @param a first matcher
 * @param b second matcher
 * @param matchers any further matchers: varargs
 * @returns {Alt}
 */
function firstOf(a, b) {
    var matchers = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        matchers[_i - 2] = arguments[_i];
    }
    return new (Alt.bind.apply(Alt, [void 0, a, b].concat(matchers)))();
}
exports.firstOf = firstOf;
/**
 * Matches first match of 2 or more matchers.
 */
var Alt = /** @class */ (function () {
    function Alt(a, b) {
        var matchers = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            matchers[_i - 2] = arguments[_i];
        }
        var matchObjects = [a, b].concat(matchers);
        this.matchers = matchObjects.map(function (m) { return Concat_1.toMatchingLogic(m); });
    }
    Object.defineProperty(Alt.prototype, "$id", {
        // tslint:disable-next-line:member-ordering
        get: function () {
            return "Alt(" + this.matchers.map(function (m) { return m.$id; }).join(",") + ")";
        },
        enumerable: true,
        configurable: true
    });
    Alt.prototype.matchPrefix = function (is, thisMatchContext, parseContext) {
        if (is.exhausted()) {
            return new MatchPrefixResult_1.MatchFailureReport(this.$id, is.offset, {});
        }
        for (var _i = 0, _a = this.matchers; _i < _a.length; _i++) {
            var matcher = _a[_i];
            var m = matcher.matchPrefix(is, thisMatchContext, parseContext);
            if (MatchPrefixResult_1.isSuccessfulMatch(m)) {
                return m;
            }
        }
        return new MatchPrefixResult_1.MatchFailureReport(this.$id, is.offset, {});
    };
    return Alt;
}());
exports.Alt = Alt;
/**
 * Add a condition with a function that verifies that even if we found a match
 * we are happy with it: For example, we like the value it contains.
 * Also capable of vetoing match if the input state is problematic before the potential match
 */
function when(o, matchTest, inputStateTest) {
    if (inputStateTest === void 0) { inputStateTest = function (is) { return true; }; }
    var matcher = Concat_1.toMatchingLogic(o);
    var conditionalMatcher = {};
    conditionalMatcher.$id = "When[" + matcher + "]";
    // Copy other properties
    for (var prop in o) {
        if (o.hasOwnProperty(prop)) {
            conditionalMatcher[prop] = o[prop];
        }
    }
    function conditionalMatch(is, thisMatchContext, parseContext) {
        var result = inputStateTest(is) ?
            matcher.matchPrefix(is, thisMatchContext, parseContext) :
            undefined;
        return (result && MatchPrefixResult_1.isSuccessfulMatch(result) && matchTest(result.match)) ?
            result :
            new MatchPrefixResult_1.MatchFailureReport(conditionalMatcher.$id, is.offset, context);
    }
    conditionalMatcher.matchPrefix = conditionalMatch;
    conditionalMatcher.requiredPrefix = matcher.requiredPrefix;
    conditionalMatcher.canStartWith = matcher.canStartWith;
    return conditionalMatcher;
}
exports.when = when;
//# sourceMappingURL=Ops.js.map