import { InputState } from "../InputState";
import { MatchingLogic } from "../Matchers";
import { MatchPrefixResult } from "../MatchPrefixResult";
/**
 * Inspired by SNOBOL BREAK: http://www.snobol4.org/docs/burks/tutorial/ch4.htm
 * In SNOBOL.
 * Used internally in Concat. Also exposed to end users in Skip functions.
 * BREAK(S) matches "up to but not including" any character in S.
 * The string matched must always be followed in the subject by a character in S.
 * Unlike SPAN and NOTANY, BREAK will match the null string.
 * This implementation goes beyond SNOBOL, in that it allows the break to consume the end token,
 * and also allows the ability to specify a pattern that must not be found.
 */
export declare class Break implements MatchingLogic {
    terminateOn: MatchingLogic;
    private consume;
    private badMatcher;
    /**
     * Consume input until (or until and including) the terminal match
     * @param terminateOn desired terminal match
     * @param consume default false. Whether to consume the terminal match. If this is set to true,
     * the value of the match will be the match of the terminal pattern. Otherwise it will the preceding,
     * skipped content.
     * @param badMatcher pattern we don't want to see before the desired determinal match.
     * If we see this pattern before, the match breaks.
     */
    constructor(terminateOn: MatchingLogic, consume?: boolean, badMatcher?: MatchingLogic);
    readonly $id: string;
    canStartWith(char: string): boolean;
    readonly requiredPrefix: string;
    matchPrefix(is: InputState, thisMatchContext: any, parseContext: any): MatchPrefixResult;
}
export declare function isBreak(thing: MatchingLogic): thing is Break;
