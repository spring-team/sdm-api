"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MatchPrefixResult_1 = require("../MatchPrefixResult");
var PatternMatch_1 = require("../PatternMatch");
var Whitespace_1 = require("./Whitespace");
/**
 * Inspired by SNOBOL BREAK: http://www.snobol4.org/docs/burks/tutorial/ch4.htm
 * In SNOBOL.
 * Used internally in Concat. Also exposed to end users in Skip functions.
 * BREAK(S) matches "up to but not including" any character in S.
 * The string matched must always be followed in the subject by a character in S.
 * Unlike SPAN and NOTANY, BREAK will match the null string.
 * This implementation goes beyond SNOBOL, in that it allows the break to consume the end token,
 * and also allows the ability to specify a pattern that must not be found.
 */
var Break = /** @class */ (function () {
    /**
     * Consume input until (or until and including) the terminal match
     * @param terminateOn desired terminal match
     * @param consume default false. Whether to consume the terminal match. If this is set to true,
     * the value of the match will be the match of the terminal pattern. Otherwise it will the preceding,
     * skipped content.
     * @param badMatcher pattern we don't want to see before the desired determinal match.
     * If we see this pattern before, the match breaks.
     */
    function Break(terminateOn, consume, badMatcher) {
        if (consume === void 0) { consume = false; }
        this.terminateOn = terminateOn;
        this.consume = consume;
        this.badMatcher = badMatcher;
    }
    Object.defineProperty(Break.prototype, "$id", {
        get: function () {
            return "Break[" + this.terminateOn.$id + "]";
        },
        enumerable: true,
        configurable: true
    });
    Break.prototype.canStartWith = function (char) {
        return (this.consume && !this.badMatcher && this.terminateOn.canStartWith) ?
            this.terminateOn.canStartWith(char) :
            true;
    };
    Object.defineProperty(Break.prototype, "requiredPrefix", {
        get: function () {
            return (this.consume && !this.badMatcher) ?
                this.terminateOn.requiredPrefix :
                undefined;
        },
        enumerable: true,
        configurable: true
    });
    Break.prototype.matchPrefix = function (is, thisMatchContext, parseContext) {
        var currentIs = is;
        var matched = "";
        // Apply optimization if possible where we skip to the terminal if we're consuming it and not avoiding a bad match
        if (this.consume && !this.badMatcher) {
            var skipped = Whitespace_1.readyToMatch(currentIs, false, this.terminateOn);
            matched += skipped.skipped;
            currentIs = skipped.state;
        }
        var terminalMatch = this.terminateOn.matchPrefix(currentIs, thisMatchContext, parseContext);
        while (!currentIs.exhausted() && !MatchPrefixResult_1.isSuccessfulMatch(terminalMatch)) {
            // But we can't match the bad match if it's defined
            if (this.badMatcher) {
                if (MatchPrefixResult_1.isSuccessfulMatch(this.badMatcher.matchPrefix(currentIs, thisMatchContext, parseContext))) {
                    return new MatchPrefixResult_1.MatchFailureReport(this.$id, is.offset);
                }
            }
            matched += currentIs.peek(1);
            currentIs = currentIs.advance();
            if (!currentIs.exhausted()) {
                terminalMatch = this.terminateOn.matchPrefix(currentIs, thisMatchContext, parseContext);
            }
        }
        // We have found the terminal if we get here
        if (this.consume && MatchPrefixResult_1.isSuccessfulMatch(terminalMatch)) {
            terminalMatch.match.$matched = matched + terminalMatch.match.$matched;
            return MatchPrefixResult_1.matchPrefixSuccess(terminalMatch.match);
        }
        return MatchPrefixResult_1.matchPrefixSuccess(new PatternMatch_1.TerminalPatternMatch(this.$id, matched, is.offset, matched));
    };
    return Break;
}());
exports.Break = Break;
function isBreak(thing) {
    return !!thing.terminateOn;
}
exports.isBreak = isBreak;
//# sourceMappingURL=Break.js.map