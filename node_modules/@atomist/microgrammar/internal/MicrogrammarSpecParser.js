"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Concat_1 = require("../matchers/Concat");
var Primitives_1 = require("../Primitives");
var PatternMatch_1 = require("../PatternMatch");
var Break_1 = require("./Break");
var CompleteFromStringOptions_1 = require("./CompleteFromStringOptions");
var ExactMatch_1 = require("./ExactMatch");
var SpecGrammar_1 = require("./SpecGrammar");
/**
 * Convenient function to create a microgrammar from a spec within another grammar
 * @param spec string spec
 * @param components
 * @param options
 * @returns {Concat}
 */
function fromString(spec, components, options) {
    if (components === void 0) { components = {}; }
    if (options === void 0) { options = {}; }
    return new MicrogrammarSpecParser().fromString(spec, components, options);
}
exports.fromString = fromString;
/**
 * Parses microgrammars expressed as strings.
 */
var MicrogrammarSpecParser = /** @class */ (function () {
    function MicrogrammarSpecParser() {
        this.anonFieldCount = 0;
    }
    MicrogrammarSpecParser.prototype.fromString = function (spec, components, options) {
        var optionsToUse = CompleteFromStringOptions_1.completeWithDefaults(options);
        spec = this.preprocess(spec, optionsToUse);
        var match = ExactMatch_1.exactMatch(SpecGrammar_1.specGrammar(optionsToUse), spec);
        if (!PatternMatch_1.isPatternMatch(match)) {
            throw new Error("Unable to parse microgrammar: " + spec);
        }
        var matcherSequence1 = this.definitionSpecsFromMicrogrammarSpec(match, components.$consumeWhiteSpaceBetweenTokens !== false);
        var matcherSequence2 = this.populateSpecifiedElements(components, matcherSequence1);
        var matcherSequence3 = this.inferUnspecifiedElements(matcherSequence2);
        var definitions = this.definitionsFromSpecs(spec, matcherSequence3);
        var concat = Concat_1.Concat.of(definitions);
        // Copy config to Concat
        for (var key in components) {
            if (key.charAt(0) === "$") {
                concat[key] = components[key];
            }
        }
        return concat;
    };
    /**
     * Given a spec, replace all the DiscardToken instances with a named,
     * but unbound, matcher spec
     * @param spec spec to preprocess before parsing
     * @param optionsToUse options
     * @returns {string}
     */
    MicrogrammarSpecParser.prototype.preprocess = function (spec, optionsToUse) {
        var split = spec.split(optionsToUse.ellipsis);
        var joined = "";
        for (var i = 0; i < split.length; i++) {
            if (i > 0) {
                joined += optionsToUse.componentPrefix + "{_discard" + i + "}";
            }
            joined += split[i];
        }
        return joined;
    };
    MicrogrammarSpecParser.prototype.definitionSpecsFromMicrogrammarSpec = function (match, consumeWhiteSpaceBetweenTokens) {
        var _this = this;
        // flatMap would work better here
        var matcherSequence1 = [];
        match.these.forEach(function (t) {
            if (t.literal.length > 0) {
                matcherSequence1.push({ anonymous: _this.matcherForLiteral(t.literal, consumeWhiteSpaceBetweenTokens) });
            }
            matcherSequence1.push({ reference: t.element.elementName });
        });
        matcherSequence1.push({ anonymous: this.matcherForLiteral(match.trailing, consumeWhiteSpaceBetweenTokens) });
        return matcherSequence1;
    };
    MicrogrammarSpecParser.prototype.populateSpecifiedElements = function (elements, definitionSpecs) {
        return definitionSpecs.map(function (t) {
            if (isReference(t) && elements[t.reference]) {
                return {
                    named: {
                        name: t.reference,
                        matcher: Concat_1.toMatchingLogic(elements[t.reference]),
                    },
                };
            }
            else {
                return t;
            }
        });
    };
    MicrogrammarSpecParser.prototype.inferUnspecifiedElements = function (definitionSpecs) {
        return definitionSpecs.map(function (s, i) {
            if (isReference(s)) {
                var next = definitionSpecs[i + 1];
                if (!next) {
                    throw new Error("I expect to have some sort of trailing matcher");
                }
                if (isReference(next)) {
                    throw new Error("There are two elements in a row without something more specific in between them");
                }
                var untilTheNextThing = new Break_1.Break(matcherFrom(next));
                return {
                    named: {
                        name: s.reference,
                        matcher: untilTheNextThing,
                    },
                };
            }
            else {
                return s;
            }
        });
    };
    MicrogrammarSpecParser.prototype.definitionsFromSpecs = function (id, definitionSpecs) {
        var _this = this;
        var definitions = { $id: id };
        definitionSpecs.forEach(function (t) {
            if (isAnonymous(t)) {
                _this.addAnonymousToDefinitions(definitions, t.anonymous);
            }
            if (isNamed(t)) {
                definitions[t.named.name] = t.named.matcher;
            }
        });
        return definitions;
    };
    MicrogrammarSpecParser.prototype.matcherForLiteral = function (literal, consumeWhiteSpaceBetweenTokens) {
        var _this = this;
        if (!consumeWhiteSpaceBetweenTokens) {
            return new Primitives_1.Literal(literal);
        }
        // TODO why, if we don't put this in, does it fail?
        // Is this just in Nashorn?
        // it gets TypeError: literal.split is not a function
        if (typeof literal === "string") {
            var whiteSpaceSeparated = literal.split(/\s/);
            if (whiteSpaceSeparated.length === 1) {
                return new Primitives_1.Literal(literal);
            }
            else {
                var definitions_1 = {};
                whiteSpaceSeparated.forEach(function (token) {
                    if (token.length > 0) {
                        _this.addAnonymousToDefinitions(definitions_1, new Primitives_1.Literal(token));
                    }
                });
                return Concat_1.Concat.of(definitions_1);
            }
        }
    };
    MicrogrammarSpecParser.prototype.addAnonymousToDefinitions = function (definitions, matcher) {
        var arbName = "_" + this.anonFieldCount++;
        definitions[arbName] = matcher;
    };
    return MicrogrammarSpecParser;
}());
exports.MicrogrammarSpecParser = MicrogrammarSpecParser;
// Dogfooding idea:
// I wonder if I could make a Rug to generate these.
// It could choose any property unique to each alternative.
// Then I could put my learnings in the Rug. For instance, this !! strategy will
// return false if the scrutinized property contains empty string >:-(
// Then, the trick is, can I also make it configure a reviewer
// that will flag an error if, say, I ever added the "named:" property
// to one of the other alternatives? (If the property used to distinguish
// ever became not unique)
// ... that reviewer could check for this structure
// and could run on TS files generally. Can it make a comment on a PR?
function isAnonymous(thing) {
    return !!thing.anonymous;
}
function isReference(thing) {
    return !!thing.reference;
}
function isNamed(thing) {
    return !!thing.named;
}
function matcherFrom(definitionSpec) {
    if (isAnonymous(definitionSpec)) {
        return definitionSpec.anonymous;
    }
    else {
        return definitionSpec.named.matcher;
    }
}
//# sourceMappingURL=MicrogrammarSpecParser.js.map