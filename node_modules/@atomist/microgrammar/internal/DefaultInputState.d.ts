import { InputState, Listeners, Skipped } from "../InputState";
import { InputStateManager } from "./InputStateManager";
/**
 * Default InputState implementation
 */
export declare class DefaultInputState implements InputState {
    private readonly ism;
    readonly offset: number;
    listeners: Listeners;
    constructor(ism: InputStateManager, offset: number, listeners?: Listeners);
    /**
     * Skip to before this pattern. Exhaust input if necessary.
     * @param what what to skip to
     * @return {InputState}
     */
    skipTo(what: string): Skipped;
    /**
     * Skip input while it matches the given function
     * @param skip skip till
     * @param n number of characters to look at
     * @return {InputState}
     */
    skipWhile(skip: (char: string) => boolean, n: number): Skipped;
    /**
     * Is the input exhausted?
     * @return {boolean}
     */
    exhausted(): boolean;
    /**
     * Consume the given string if our input begins with it. Otherwise fail
     * @param s string that we must find
     * @param message activity we're performing
     * @return {InputState}
     */
    consume(s: string, message: string): InputState;
    /**
     * Advance one character in the input
     * @return {InputState}
     */
    advance(): InputState;
    /**
     * Look ahead in the input without consuming characters
     * @param n number of characters to look ahead
     * @return {string}
     */
    peek(n: number): string;
    /**
     * What substring has been read since the given state
     * @param l previous input state
     * @return {string}
     */
    private seenSince(l);
}
