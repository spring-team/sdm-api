"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ChangeSet_1 = require("./ChangeSet");
var PatternMatch_1 = require("../PatternMatch");
/**
 * Handle low level updating using get/set properties
 */
var MicrogrammarUpdates = /** @class */ (function () {
    function MicrogrammarUpdates() {
    }
    MicrogrammarUpdates.prototype.updatableMatch = function (match, cs) {
        var changeSet = (typeof cs === "string") ? new ChangeSet_1.ChangeSet(cs) : cs;
        var updating = {
            $changeSet: changeSet,
            newContent: function () {
                return this.$changeSet.updated();
            },
            replaceAll: function (newValue) {
                this.$changeSet.change(match, newValue);
            },
        };
        this.addMatchesAsProperties(updating, updating.$changeSet, match);
        return updating;
    };
    /**
     * adds each match as a property to the target, with setters that update the changeset
     * @param target
     * @param cs
     * @param match
     */
    MicrogrammarUpdates.prototype.addMatchesAsProperties = function (target, cs, match) {
        if (PatternMatch_1.isTreePatternMatch(match)) {
            var submatches = match.submatches();
            var _loop_1 = function (key) {
                var submatch = submatches[key];
                var initialValue = void 0;
                if (PatternMatch_1.isTreePatternMatch(submatch) && submatch.submatches() === {}) {
                    initialValue = submatch.$matched; // or $value ? they should both be the string value.
                    // this could also be derived from content + offset, which reduces memory consumption
                }
                else if (PatternMatch_1.isTreePatternMatch(submatch)) {
                    initialValue = {};
                    this_1.addMatchesAsProperties(initialValue, cs, submatch);
                }
                else if (submatch) {
                    initialValue = submatch.$value;
                }
                var privateProperty = "_" + key;
                // https://stackoverflow.com/questions/12827266/get-and-set-in-typescript
                target[privateProperty] = initialValue;
                Object.defineProperty(target, key, {
                    get: function () {
                        return (target.$invalidated) ?
                            undefined :
                            this[privateProperty];
                    },
                    set: function (newValue) {
                        if (target.$invalidated) {
                            throw new Error("Cannot set [" + key + "] on [" + target + "]: invalidated by parent change");
                        }
                        target[privateProperty] = newValue;
                        cs.change(submatch, newValue);
                        if (PatternMatch_1.isTreePatternMatch(submatch) && submatch.submatches() !== {}) {
                            // The caller has set the value of an entire property block.
                            // Invalidate the properties under it
                            for (var _i = 0, _a = Object.getOwnPropertyNames(target); _i < _a.length; _i++) {
                                var prop = _a[_i];
                                if (typeof target[prop] === "object") {
                                    target[prop].$invalidated = true;
                                }
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true,
                });
            };
            var this_1 = this;
            // tslint:disable-next-line:forin
            for (var key in submatches) {
                _loop_1(key);
            }
        }
        else {
            // console.log(`Not a tree pattern match: ${JSON.stringify(match)}`);
        }
    };
    return MicrogrammarUpdates;
}());
exports.MicrogrammarUpdates = MicrogrammarUpdates;
//# sourceMappingURL=MicrogrammarUpdates.js.map