"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function replaceFirstAfter(content, offset, old, replacement) {
    return content.substring(0, offset) + content.substring(offset).replace(old, replacement);
}
// TODO this should also support streaming
var ChangeSet = /** @class */ (function () {
    function ChangeSet(initialContent) {
        this.initialContent = initialContent;
        this.changes = [];
    }
    ChangeSet.prototype.change = function (match, to) {
        var change = new Change(match, to);
        // Don't add twice: update
        var found = this.changes.filter(function (c) { return c.match === match; });
        if (found.length === 0) {
            this.changes.push(change);
            // Keep sorted with latest first
            this.changes.sort(function (pm1, pm2) { return pm2.match.$offset - pm1.match.$offset; });
        }
        else {
            var idx = this.changes.indexOf(found[0]);
            this.changes[idx] = change;
        }
    };
    ChangeSet.prototype.updated = function () {
        if (this.changes.length === 0) {
            return this.initialContent;
        }
        var result = this.initialContent;
        for (var _i = 0, _a = this.changes; _i < _a.length; _i++) {
            var change = _a[_i];
            // console.log(`Applying change at ${change.match.$offset} to ${change.to}`)
            result = replaceFirstAfter(result, change.match.$offset, change.match.$matched, change.to);
        }
        if (!result) {
            throw new Error("Anomaly: !result");
        }
        return result;
    };
    return ChangeSet;
}());
exports.ChangeSet = ChangeSet;
var Change = /** @class */ (function () {
    function Change(match, to) {
        this.match = match;
        this.to = to;
        if (match.$offset === undefined) {
            throw new Error("No offset on match with id [" + match.$matcherId + "]: matched=[" + match.$matched + "]");
        }
    }
    return Change;
}());
//# sourceMappingURL=ChangeSet.js.map