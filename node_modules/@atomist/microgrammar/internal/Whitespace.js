"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Prepare to match. Skip whitespace if appropriate. Skip irrelevant content if
 * we have a matcher we're preparing for.
 * @param is current input state
 * @param consumeWhiteSpaceBetweenTokens should we skipWhile whitespace
 * @param matchers matchers we want to match. If there are multiple matchers,
 * we calculate the longest common prefix (if known). Undefined array
 * elements are ignored, after the first matcher.
 * If there is a definite prefix, we can skipWhile content.
 */
function readyToMatch(is, consumeWhiteSpaceBetweenTokens) {
    var matchers = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        matchers[_i - 2] = arguments[_i];
    }
    var lookFor = commonPrefix(matchers);
    if (lookFor) {
        return is.skipTo(lookFor);
    }
    else if (consumeWhiteSpaceBetweenTokens) {
        return is.skipWhile(function (c) { return c.trim() === ""; }, 1); // || m && m.canStartWith && !m.canStartWith(c));
    }
    else {
        return { skipped: "", state: is };
    }
}
exports.readyToMatch = readyToMatch;
/**
 * Find a common prefix that all these matchers share
 */
function commonPrefix(matchers) {
    if (matchers.length === 0) {
        return undefined;
    }
    if (matchers.length === 1) {
        return matchers[0].requiredPrefix;
    }
    var prefixes = matchers.filter(function (m) { return m !== undefined; }).map(function (m) { return m.requiredPrefix; });
    if (prefixes.indexOf(undefined) !== -1) {
        return undefined;
    }
    return sharedStart(prefixes);
}
// See https://stackoverflow.com/questions/1916218/
// find-the-longest-common-starting-substring-in-a-set-of-strings/1917041#1917041
function sharedStart(array) {
    var A = array.concat().sort();
    var a1 = A[0];
    var a2 = A[A.length - 1];
    var L = a1.length;
    var i = 0;
    while (i < L && a1.charAt(i) === a2.charAt(i)) {
        i++;
    }
    return a1.substring(0, i);
}
//# sourceMappingURL=Whitespace.js.map