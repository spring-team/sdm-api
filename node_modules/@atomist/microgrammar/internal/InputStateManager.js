"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DEFAULT_BUFFER_SIZE = 5000;
/**
 * Window over input. Enables us to use a simple InputStream
 * abstraction that does not need to support backtracking.
 */
var InputStateManager = /** @class */ (function () {
    function InputStateManager(stream, bufsize) {
        if (bufsize === void 0) { bufsize = DEFAULT_BUFFER_SIZE; }
        this.stream = stream;
        this.bufsize = bufsize;
        this.left = 0;
        this.window = "";
    }
    InputStateManager.prototype.get = function (offset, n) {
        this.canSatisfy(offset + n);
        return this.window.substr(offset - this.left, n);
    };
    InputStateManager.prototype.canSatisfy = function (offset) {
        if (offset < this.left) {
            throw new Error("Cannot rewind to offset " + offset + ": already at " + this.left);
        }
        if (offset > this.right()) {
            this.window += this.stream.read(Math.max(this.bufsize, offset - this.right()));
        }
        return this.right() >= offset;
    };
    /**
     * Drop characters left of the offset from window
     * @param offset leftmost offset we'll need
     */
    InputStateManager.prototype.dropLeft = function (offset) {
        if (offset > this.left && offset <= this.right()) {
            this.window = this.window.substr(offset - this.left);
            this.left = offset;
        }
    };
    InputStateManager.prototype.exhausted = function () {
        return this.window.length === 0 && this.stream.exhausted();
    };
    InputStateManager.prototype.right = function () {
        return this.left + this.window.length;
    };
    return InputStateManager;
}());
exports.InputStateManager = InputStateManager;
//# sourceMappingURL=InputStateManager.js.map