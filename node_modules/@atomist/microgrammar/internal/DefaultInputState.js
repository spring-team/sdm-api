"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Default InputState implementation
 */
var DefaultInputState = /** @class */ (function () {
    function DefaultInputState(ism, offset, listeners) {
        this.ism = ism;
        this.offset = offset;
        this.listeners = listeners;
    }
    /**
     * Skip to before this pattern. Exhaust input if necessary.
     * @param what what to skip to
     * @return {InputState}
     */
    DefaultInputState.prototype.skipTo = function (what) {
        return this.skipWhile(function (s) { return s !== what; }, what.length);
    };
    /**
     * Skip input while it matches the given function
     * @param skip skip till
     * @param n number of characters to look at
     * @return {InputState}
     */
    DefaultInputState.prototype.skipWhile = function (skip, n) {
        var offset = this.offset;
        while (this.ism.canSatisfy(offset) && skip(this.ism.get(offset, n))) {
            ++offset;
        }
        var is = new DefaultInputState(this.ism, offset);
        var skipped = is.seenSince(this);
        if (this.listeners) {
            is.listeners = cloneListeners(this.listeners, skipped);
        }
        return { skipped: skipped, state: is };
    };
    /**
     * Is the input exhausted?
     * @return {boolean}
     */
    DefaultInputState.prototype.exhausted = function () {
        return !this.ism.canSatisfy(this.offset);
    };
    /**
     * Consume the given string if our input begins with it. Otherwise fail
     * @param s string that we must find
     * @param message activity we're performing
     * @return {InputState}
     */
    DefaultInputState.prototype.consume = function (s, message) {
        var actual = this.ism.get(this.offset, s.length);
        if (actual !== s) {
            throw new Error("Invalid call to InputState.consume: Cannot consume [" + s + "] from [" + actual + "]. Log: " + message);
        }
        return new DefaultInputState(this.ism, this.offset + s.length, cloneListeners(this.listeners, s));
    };
    /**
     * Advance one character in the input
     * @return {InputState}
     */
    DefaultInputState.prototype.advance = function () {
        if (!this.listeners) {
            // If there are no listeners we can short circuit this
            return new DefaultInputState(this.ism, this.offset + 1, undefined);
        }
        else {
            // We need to notify listeners of what we read
            var next = this.peek(1);
            if (next.length === 0) {
                throw new Error("Illegal call to InputState.advance: Stream is exhausted");
            }
            return new DefaultInputState(this.ism, this.offset + 1, cloneListeners(this.listeners, next));
        }
    };
    /**
     * Look ahead in the input without consuming characters
     * @param n number of characters to look ahead
     * @return {string}
     */
    DefaultInputState.prototype.peek = function (n) {
        return this.ism.get(this.offset, n);
    };
    /**
     * What substring has been read since the given state
     * @param l previous input state
     * @return {string}
     */
    DefaultInputState.prototype.seenSince = function (l) {
        return this.ism.get(l.offset, this.offset - l.offset);
    };
    return DefaultInputState;
}());
exports.DefaultInputState = DefaultInputState;
/**
 * Clone the given listeners object
 * @param l object to clone
 * @param s string for the clone to read, if defined
 * @returns {any}
 */
function cloneListeners(l, s) {
    if (!l) {
        return undefined;
    }
    var cloned = {};
    for (var _i = 0, _a = Object.keys(l); _i < _a.length; _i++) {
        var key = _a[_i];
        cloned[key] = l[key].clone();
        if (s) {
            cloned[key].read(s);
        }
    }
    return cloned;
}
//# sourceMappingURL=DefaultInputState.js.map