"use strict";
/*
 * Copyright Â© 2017 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var deprecated_decorator_1 = require("deprecated-decorator");
var SlackMessages_1 = require("./SlackMessages");
exports.ErrorColor = "#D94649";
exports.SuccessColor = "#45B254";
exports.WarningColor = "#FFCC00";
var Identifiable = /** @class */ (function () {
    function Identifiable() {
    }
    return Identifiable;
}());
exports.Identifiable = Identifiable;
var UserAddress = /** @class */ (function () {
    function UserAddress(username) {
        this.username = username;
    }
    return UserAddress;
}());
exports.UserAddress = UserAddress;
var ChannelAddress = /** @class */ (function () {
    function ChannelAddress(channelName) {
        this.channelName = channelName;
    }
    return ChannelAddress;
}());
exports.ChannelAddress = ChannelAddress;
/**
 * A Rug message parent class for response and direct messages.
 */
var LocallyRenderedMessage = /** @class */ (function () {
    function LocallyRenderedMessage() {
        this.contentType = SlackMessages_1.MessageMimeTypes.PlainText;
        this.instructions = [];
    }
    return LocallyRenderedMessage;
}());
exports.LocallyRenderedMessage = LocallyRenderedMessage;
/**
 * Represents the response to the bot from a command.
 */
var ResponseMessage = /** @class */ (function (_super) {
    __extends(ResponseMessage, _super);
    function ResponseMessage(body, contentType) {
        var _this = _super.call(this) || this;
        _this.kind = "response";
        _this.body = body;
        if (contentType) {
            _this.contentType = contentType;
        }
        return _this;
    }
    return ResponseMessage;
}(LocallyRenderedMessage));
exports.ResponseMessage = ResponseMessage;
/**
 * Message unrelated to extant communications with the bot.
 */
var DirectedMessage = /** @class */ (function (_super) {
    __extends(DirectedMessage, _super);
    function DirectedMessage(body, address, contentType) {
        var _this = _super.call(this) || this;
        _this.kind = "directed";
        _this.usernames = [];
        _this.channelNames = [];
        _this.body = body;
        if (contentType) {
            _this.contentType = contentType;
        }
        _this.addAddress(address);
        return _this;
    }
    DirectedMessage.prototype.addAddress = function (address) {
        if (address instanceof UserAddress) {
            this.usernames.push(address.username);
        }
        else {
            this.channelNames.push(address.channelName);
        }
        return this;
    };
    DirectedMessage.prototype.addAction = function (instruction) {
        this.instructions.push(instruction);
        return this;
    };
    return DirectedMessage;
}(LocallyRenderedMessage));
exports.DirectedMessage = DirectedMessage;
/**
 * Populate standard message attachment with defaults if value not set.
 *
 * @param a attachment to ensure populated, possibly modified by this function
 * @param sm default values
 * @return populated attachment
 */
function standardAttachment(a, sm) {
    a.fallback = a.fallback || sm.kind + "!";
    a.text = a.text || a.fallback;
    a.author_name = a.author_name || sm.kind + ": " + a.fallback;
    a.author_icon = a.author_icon || sm.image;
    a.color = a.color || sm.color;
    a.mrkdwn_in = a.mrkdwn_in || ["text"];
    return a;
}
/**
 * Create a standard Slack error message.  The attachment should
 * contain at least a non-empty fallback property.  The text property
 * will be augmented with information about getting help.  If the text
 * property is not provided, the fallback is used as a base for the
 * fallback.  Title icons and message will be added if they are not
 * present.
 *
 * @param attachment  message content
 * @param correlationId correlation ID for transaction that failed,
 *                      which will appear in the footer if it is not already set
 * @return a Slack error message using attachments which will need to be `render`ed
 */
function errorMessage(attachment, correlationId) {
    var defaults = {
        kind: "Error",
        image: "https://images.atomist.com/rug/error-circle.png",
        color: exports.ErrorColor,
    };
    attachment = standardAttachment(attachment, defaults);
    var supportUrl = "https://atomist-community.slack.com/messages/C29GYTYDC/";
    attachment.text += "\nPlease contact " + SlackMessages_1.url(supportUrl, "Atomist support");
    if (!attachment.footer && correlationId) {
        attachment.text += ", providing the correlation ID below";
        attachment.footer = "Correlation ID: " + correlationId;
    }
    attachment.text += ". Sorry for the inconvenience.";
    var message = { attachments: [attachment] };
    return message;
}
exports.errorMessage = errorMessage;
/**
 * Create a standard Slack success message.  The attachment should
 * contain at least a non-empty fallback property.  If the text
 * property is not provided, the fallback is used.  Title icons and
 * message will be added if they are not present.
 *
 * @param attachment  message content
 * @return a Slack success message using attachments which will need to be `render`ed
 */
function successMessage(attachment) {
    var defaults = {
        kind: "Success",
        image: "https://images.atomist.com/rug/check-circle.png",
        color: exports.SuccessColor,
    };
    attachment = standardAttachment(attachment, defaults);
    var message = { attachments: [attachment] };
    return message;
}
exports.successMessage = successMessage;
/**
 * Create a standard Slack warning message.  The attachment should
 * contain at least a non-empty fallback property.  If the text
 * property is not provided, the fallback is used.  Title icons and
 * message will be added if they are not present.
 *
 * @param attachment  message content
 * @return a Slack warning message using attachments which will need to be `render`ed
 */
function warningMessage(attachment) {
    var defaults = {
        kind: "Warning",
        image: "https://images.atomist.com/rug/error-square.png",
        color: exports.WarningColor,
    };
    attachment = standardAttachment(attachment, defaults);
    var message = { attachments: [attachment] };
    return message;
}
exports.warningMessage = warningMessage;
/**
 * Create a Rug error ResponseMessage.  If rendering fails, a text
 * response message of attachment.fallback is returned.
 *
 * @param msg text of Slack message
 * @param correlationId correlation ID of transaction that failed
 * @return Rug error ResponseMessage
 */
function errorResponse(attachment, correlationId) {
    try {
        var slackMessage = errorMessage(attachment, correlationId);
        return new ResponseMessage(SlackMessages_1.render(slackMessage), SlackMessages_1.MessageMimeTypes.SlackJson);
    }
    catch (e) {
        var err = e;
        console.error("failed to render message '" + attachment + "':" + err.name + ":" + err.message + ":" + err.stack);
        return new ResponseMessage(attachment.fallback);
    }
}
exports.errorResponse = errorResponse;
/**
 * Create a Rug success ResponseMessage.  If rendering fails, a text
 * response message of attachment.fallback is returned.
 *
 * @param msg text of Slack message
 * @return Rug success ResponseMessage
 */
function successResponse(attachment) {
    try {
        var slackMessage = successMessage(attachment);
        return new ResponseMessage(SlackMessages_1.render(slackMessage), SlackMessages_1.MessageMimeTypes.SlackJson);
    }
    catch (e) {
        var err = e;
        console.error("failed to render message '" + attachment + "':" + err.name + ":" + err.message + ":" + err.stack);
        return new ResponseMessage(attachment.fallback);
    }
}
exports.successResponse = successResponse;
/**
 * Create a Rug warning ResponseMessage.  If rendering fails, a text
 * response message of attachment.fallback is returned.
 *
 * @param msg text of Slack message
 * @return Rug warning ResponseMessage
 */
function warningResponse(attachment) {
    try {
        var slackMessage = warningMessage(attachment);
        return new ResponseMessage(SlackMessages_1.render(slackMessage), SlackMessages_1.MessageMimeTypes.SlackJson);
    }
    catch (e) {
        var err = e;
        console.error("failed to render message '" + attachment + "':" + err.name + ":" + err.message + ":" + err.stack);
        return new ResponseMessage(attachment.fallback);
    }
}
exports.warningResponse = warningResponse;
/* tslint:disable:no-shadowed-variable */
exports.renderError = deprecated_decorator_1.deprecated({
    alternative: "errorResponse",
    version: "0.8.0",
}, function renderError(msg, correlationId) {
    try {
        var error = {
            text: msg,
            author_name: "Unable to run command",
            author_icon: "https://images.atomist.com/rug/error-circle.png",
            fallback: "Unable to run command",
            mrkdwn_in: ["text"],
            color: "#D94649",
        };
        if (correlationId) {
            error.footer = "Correlation ID: " + correlationId;
        }
        var slackMessage = {
            attachments: [error],
        };
        return new ResponseMessage(SlackMessages_1.render(slackMessage), SlackMessages_1.MessageMimeTypes.SlackJson);
    }
    catch (ex) {
        return new ResponseMessage("Error rendering error message " + ex);
    }
});
exports.renderSuccess = deprecated_decorator_1.deprecated({
    alternative: "successResponse",
    version: "0.8.0",
}, function renderSuccess(msg) {
    try {
        var slackMessage = { text: msg };
        return new ResponseMessage(SlackMessages_1.render(slackMessage), SlackMessages_1.MessageMimeTypes.SlackJson);
    }
    catch (ex) {
        return exports.renderError("Error rendering success message " + ex);
    }
});
//# sourceMappingURL=RugMessages.js.map