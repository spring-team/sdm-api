/**
 * Defines an Ingester as per automation-api
 *
 * An Ingester is a collection of GraphQL types and a pointer to the root type in the
 * root_type field.
 */
export interface Ingester {
    root_type: any | string;
    types: Array<ObjectType | EnumType>;
}
/**
 * Describes root level GraphQL types
 */
export interface ObjectType {
    kind: "OBJECT";
    name: string;
    description?: string;
    fields: FieldType[];
}
/**
 * Describes root level GraphQL enums
 */
export interface EnumType {
    kind: "ENUM";
    name: string;
    description?: string;
    enumValues: Array<{
        name: string;
    }>;
}
/**
 * Describes fields of ObjectType root level GraphQL types
 */
export interface FieldType {
    name: string;
    description?: string;
    args?: FieldType[];
    type: {
        kind: "SCALAR" | "LIST" | "OBJECT" | "ENUM";
        name?: string | "String" | "Int" | "Float" | "Boolean";
        ofType?: {
            kind: "OBJECT" | "SCALAR";
            name: string;
        };
    };
    directives?: Array<{
        name: string;
    }>;
    defaultValue?: any;
}
/**
 * Builder to construct Ingester instances fluently
 */
export declare class IngesterBuilder {
    rootType: string | TypeBuilder;
    private types;
    private enums;
    private name;
    constructor(rootType: string | TypeBuilder);
    withType(builder: TypeBuilder): IngesterBuilder;
    withEnum(builder: EnumBuilder): IngesterBuilder;
    build(): Ingester;
}
/**
 * Builder to construct TypeBuilder instances fluently
 */
export declare class TypeBuilder {
    name: string;
    description: string;
    private fields;
    constructor(name: string, description?: string);
    withScalarField(name: string, kind: "String" | "Int" | "Float" | "Boolean", description?: string, directives?: string[]): TypeBuilder;
    withObjectField(name: string, object: string | TypeBuilder, description?: string, args?: string[], directives?: string[]): TypeBuilder;
    withEnumField(name: string, object: string | EnumBuilder, description?: string, directives?: string[]): this;
    withStringField(name: string, description?: string, directives?: string[]): TypeBuilder;
    withBooleanField(name: string, description?: string, directives?: string[]): TypeBuilder;
    withFloatField(name: string, description?: string, directives?: string[]): TypeBuilder;
    withIntField(name: string, description?: string, directives?: string[]): TypeBuilder;
    withListScalarField(name: string, kind: "String" | "Int" | "Float" | "Boolean", description?: string): TypeBuilder;
    withListObjectField(name: string, object: string | TypeBuilder, description?: string, args?: string[]): TypeBuilder;
    build(types: ObjectType[]): ObjectType;
}
/**
 * Builder to construct EnumType instances fluently
 */
export declare class EnumBuilder {
    name: string;
    values: string[];
    description: string;
    constructor(name: string, values: string[], description?: string);
    build(): EnumType;
}
/**
 * Create an IngesterBuilder for the provided rootType
 *
 * If rootType is TypeBuilder instance, it is added to the types collection.
 * Therefore there is no need to call withType on the rootType.
 * @param {string | TypeBuilder} rootType
 * @returns {IngesterBuilder}
 */
export declare function buildIngester(rootType: string | TypeBuilder): IngesterBuilder;
/**
 * Create a TypeBuilder for the provided name
 * @param {string} name
 * @returns {TypeBuilder}
 */
export declare function buildType(name: string): TypeBuilder;
/**
 * Create a EnumBuilder for the provided name, description and values
 * @param {string} name
 * @param {string[]} values
 * @param {string} description
 * @returns {EnumBuilder}
 */
export declare function buildEnum(name: string, values: string[], description?: string): EnumBuilder;
