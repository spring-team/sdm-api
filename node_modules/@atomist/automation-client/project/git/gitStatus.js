"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const commandLine_1 = require("../../action/cli/commandLine");
function isFullyClean(gs) {
    return gs.isClean && gs.ignoredChanges.length === 0;
}
exports.isFullyClean = isFullyClean;
function runStatusIn(baseDir) {
    return determineBranch(baseDir)
        .then(branch => collectUpstream(baseDir, branch)
        .then(upstreamData => collectFullSha(baseDir)
        .then(shaData => collectCleanliness(baseDir)
        .then(cleanlinessData => collectIgnoredChanges(baseDir)
        .then(ignoredChangeData => Promise.resolve(Object.assign({ branch }, ignoredChangeData, cleanlinessData, shaData, upstreamData)))))));
}
exports.runStatusIn = runStatusIn;
function determineBranch(baseDir) {
    return runIn(baseDir, "git rev-parse --abbrev-ref HEAD")
        .then(branchNameResult => {
        return branchNameResult.stdout.trim();
    });
}
function collectCleanliness(baseDir) {
    return runIn(baseDir, "git status --porcelain")
        .then(porcelainStatusResult => {
        const raw = porcelainStatusResult.stdout;
        return { isClean: (raw.length) === 0 };
    });
}
function collectIgnoredChanges(baseDir) {
    return runIn(baseDir, "git status --porcelain --ignored")
        .then(porcelainStatusResult => {
        const raw = porcelainStatusResult.stdout;
        const ignored = raw.trim()
            .split("\n")
            .filter(s => s.startsWith("!"))
            .map(s => s.substring(3));
        return {
            raw,
            ignoredChanges: ignored,
        };
    });
}
function collectFullSha(baseDir, commit = "HEAD") {
    return runIn(baseDir, `git rev-list -1 ${commit} --`).then(result => {
        return {
            sha: result.stdout.trim(),
        };
    });
}
function collectUpstream(baseDir, branch) {
    return runIn(baseDir, `git for-each-ref --format "%(upstream:short) %(upstream:trackshort)" refs/heads/${branch}`)
        .then(branchResult => {
        const branchResultParts = branchResult.stdout.trim().split(" ");
        const upstream = branchResultParts.length > 0 ?
            { branch: branchResultParts[0], inSync: branchResultParts[1] === "=" }
            : undefined;
        return { upstream };
    });
}
function runIn(baseDir, command) {
    return commandLine_1.runCommand(command, { cwd: baseDir });
}
//# sourceMappingURL=gitStatus.js.map