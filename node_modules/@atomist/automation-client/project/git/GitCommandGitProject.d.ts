import { ActionResult } from "../../action/ActionResult";
import { CommandResult } from "../../action/cli/commandLine";
import { ProjectOperationCredentials } from "../../operations/common/ProjectOperationCredentials";
import { RemoteRepoRef, RepoRef } from "../../operations/common/RepoId";
import { CloneOptions, DirectoryManager } from "../../spi/clone/DirectoryManager";
import { ReleaseFunction } from "../local/LocalProject";
import { NodeFsLocalProject } from "../local/NodeFsLocalProject";
import { Project } from "../Project";
import { GitProject, GitPushOptions } from "./GitProject";
import { GitStatus } from "./gitStatus";
export declare const DefaultDirectoryManager: DirectoryManager;
/**
 * Implements GitProject interface using the Git binary from the command line.
 * Works only if git is installed.
 */
export declare class GitCommandGitProject extends NodeFsLocalProject implements GitProject {
    baseDir: string;
    private credentials;
    provenance: string;
    static fromProject(p: Project, credentials: ProjectOperationCredentials): GitProject;
    /**
     * Create a project from an existing git directory
     * @param {RepoRef} id
     * @param {string} baseDir
     * @param {ProjectOperationCredentials} credentials
     * @param release call this when you're done with the project. make its filesystem resources available to others.
     * @param provenance optional; for debugging, describe how this was constructed
     * @return {GitCommandGitProject}
     */
    static fromBaseDir(id: RepoRef, baseDir: string, credentials: ProjectOperationCredentials, release: ReleaseFunction, provenance?: string): GitCommandGitProject;
    /**
     * Create a new GitCommandGitProject by cloning the given remote project
     * @param {ProjectOperationCredentials} credentials
     * @param {RemoteRepoRef} id
     * @param {CloneOptions} opts
     * @param {DirectoryManager} directoryManager
     * @return {Promise<GitCommandGitProject>}
     */
    static cloned(credentials: ProjectOperationCredentials, id: RemoteRepoRef, opts?: CloneOptions, directoryManager?: DirectoryManager): Promise<GitProject>;
    branch: string;
    remote: string;
    newRepo: boolean;
    private constructor();
    init(): Promise<CommandResult<this>>;
    /**
     * Deprecated; use gitStatus().then(status => status.isClean) instead
     */
    isClean(): Promise<CommandResult<this>>;
    gitStatus(): Promise<GitStatus>;
    /**
     * Remote is of form https://github.com/USERNAME/REPOSITORY.git
     * @param remote
     */
    setRemote(remote: string): Promise<CommandResult<this>>;
    setUserConfig(user: string, email: string): Promise<CommandResult<this>>;
    createAndSetRemote(gid: RemoteRepoRef, description: string, visibility: "private" | "public"): Promise<CommandResult<this>>;
    configureFromRemote(): Promise<ActionResult<this>>;
    /**
     * Raise a PR after a push to this branch
     * @param title
     * @param body
     */
    raisePullRequest(title: string, body?: string, targetBranch?: string): Promise<ActionResult<this>>;
    /**
     * `git add .` and `git commit`
     * @param {string} message
     * @returns {Promise<CommandResult<this>>}
     */
    commit(message: string): Promise<CommandResult<this>>;
    /**
     * Check out a particular commit. We'll end in detached head state
     * @param sha
     * @return {any}
     */
    checkout(sha: string): Promise<CommandResult<this>>;
    /**
     * Revert all changes since last commit
     * @return {any}
     */
    revert(): Promise<CommandResult<this>>;
    push(options?: GitPushOptions): Promise<CommandResult<this>>;
    createBranch(name: string): Promise<CommandResult<this>>;
    hasBranch(name: string): Promise<boolean>;
    private runCommandInCurrentWorkingDirectory(cmd);
}
