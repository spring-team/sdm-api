"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Flushable_1 = require("../../internal/common/Flushable");
const async_1 = require("../../internal/util/async");
/**
 * Promise of an array of files. Usually sourced from Project.streamFiles
 */
function toPromise(stream) {
    return new Promise((resolve, reject) => {
        const files = [];
        stream
            .on("data", f => files.push(f))
            .on("error", reject)
            .on("end", _ => resolve(files));
    });
}
exports.toPromise = toPromise;
/**
 * Does at least one file matching the given predicate exist in this project?
 * No guarantees about ordering
 * @param p
 * @param globPattern
 * @param test
 * @return {Promise<boolean>}
 */
function fileExists(p, globPattern, test) {
    return saveFromFiles(p, globPattern, f => test(f) === true)
        .then(results => results.length > 0);
}
exports.fileExists = fileExists;
/**
 * Gather data from a set of files
 * @param project project to act on
 * @param globPattern glob pattern for files to match
 * @param gather function that saves a value from a file or discards it
 * by returning undefined
 * @return {Promise<T>}
 */
function saveFromFiles(project, globPattern, gather) {
    return new Promise((resolve, reject) => {
        const gathered = [];
        project.streamFiles(globPattern)
            .on("data", f => {
            const g = gather(f);
            if (g) {
                gathered.push(g);
            }
        })
            .on("error", reject)
            .on("end", _ => {
            resolve(gathered);
        });
    });
}
exports.saveFromFiles = saveFromFiles;
/**
 * Same as saveFromFiles, but works with promise returns
 * @param {ProjectAsync} project to act on
 * @param {string} globPattern glob pattern for files to match
 * @param {(f: File) => Promise<T>} gather function returning a promise from each file
 * @return {Promise<T[]>}
 */
function saveFromFilesAsync(project, globPattern, gather) {
    return new Promise((resolve, reject) => {
        const gathered = [];
        project.streamFiles(globPattern)
            .on("data", f => {
            const g = gather(f);
            if (g) {
                gathered.push(g);
            }
        })
            .on("error", reject)
            .on("end", _ => {
            resolve(Promise.all(gathered).then(ts => ts.filter(t => !!t)));
        });
    });
}
exports.saveFromFilesAsync = saveFromFilesAsync;
/**
 * Perform the same operation on all the files.
 * @param project project to act on
 * @param globPattern glob pattern to match
 * @param op operation to perform on files. Can return void or a promise.
 */
function doWithFiles(project, globPattern, op) {
    return new Promise((resolve, reject) => {
        const filePromises = [];
        return project.streamFiles(globPattern)
            .on("data", f => {
            const r = op(f);
            if (async_1.isPromise(r)) {
                filePromises.push(r.then(_ => f.flush()));
            }
            else {
                if (f.dirty) {
                    filePromises.push(f.flush());
                }
            }
        })
            .on("error", reject)
            .on("end", _ => {
            resolve(Promise.all(filePromises));
        });
    }).then(files => project);
}
exports.doWithFiles = doWithFiles;
/**
 * Delete files matching the glob pattern and extra test (if supplied)
 * @param project project to act on
 * @param globPattern glob pattern for files to delete
 * @param test additional, optional test for files to be deleted
 */
function deleteFiles(project, globPattern, test = f => true) {
    return new Promise((resolve, reject) => {
        let deleted = 0;
        project.streamFiles(globPattern)
            .on("data", f => {
            if (test(f)) {
                ++deleted;
                Flushable_1.defer(project, project.deleteFile(f.path));
            }
        })
            .on("error", reject)
            .on("end", () => {
            resolve(project.flush()
                .then(() => deleted));
        });
    });
}
exports.deleteFiles = deleteFiles;
//# sourceMappingURL=projectUtils.js.map