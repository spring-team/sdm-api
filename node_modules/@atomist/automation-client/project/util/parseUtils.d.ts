import { File } from "../File";
import { Microgrammar } from "@atomist/microgrammar/Microgrammar";
import { PatternMatch } from "@atomist/microgrammar/PatternMatch";
import { ProjectAsync } from "../Project";
export declare type Match<M> = M & PatternMatch;
/**
 * Matches within a particular file
 */
export interface FileWithMatches<M> {
    file: File;
    content: string;
    matches: Array<Match<M>>;
    /**
     * Make matches updatable
     */
    makeUpdatable(): void;
}
/**
 * Options for microgrammar matching
 */
export interface Opts {
    /**
     * Should we make the results updatable?
     */
    makeUpdatable?: boolean;
    /**
     * If specified, transforms content of each file matched
     * by the glob before running the microgrammar.
     * Used to remove comments etc.
     * @param {string} content
     * @return {string}
     */
    contentTransformer?: (content: string) => string;
}
export declare const DefaultOpts: Opts;
/**
 * Integrate microgrammars with project operations to find all matches
 * @param p project
 * @param globPattern file glob pattern
 * @param microgrammar microgrammar to run against each eligible file
 * @param opts options
 */
export declare function findMatches<M>(p: ProjectAsync, globPattern: string, microgrammar: Microgrammar<M>, opts?: Opts): Promise<Array<Match<M>>>;
/**
 * Integrate microgrammars with project operations to find all matches
 * @param p project
 * @param globPattern file glob pattern
 * @param microgrammar microgrammar to run against each eligible file
 * @param opts options
 */
export declare function findFileMatches<M>(p: ProjectAsync, globPattern: string, microgrammar: Microgrammar<M>, opts?: Opts): Promise<Array<FileWithMatches<M>>>;
/**
 * Manipulate each file match containing an actual match. Will automatically match if necessary.
 * @param p project
 * @param {string} globPattern
 * @param {Microgrammar<M>} microgrammar
 * @param {(fh: FileWithMatches<M>) => void} action
 * @param opts options
 */
export declare function doWithFileMatches<M, P extends ProjectAsync = ProjectAsync>(p: P, globPattern: string, microgrammar: Microgrammar<M>, action: (fh: FileWithMatches<M>) => void, opts?: Opts): Promise<P>;
/**
 * Convenience function to operate on matches in the project.
 * Works regardless of the number of matches
 * @param p project
 * @param {string} globPattern
 * @param {Microgrammar<M>} microgrammar
 * @param {(m: M) => void} action
 * @param {{makeUpdatable: boolean}} opts
 */
export declare function doWithMatches<M, P extends ProjectAsync = ProjectAsync>(p: P, globPattern: string, microgrammar: Microgrammar<M>, action: (m: M) => void, opts?: Opts): Promise<P>;
/**
 * Convenience function to operate on the sole match in the project.
 * Fail if zero or more than one.
 * @param p project
 * @param {string} globPattern
 * @param {Microgrammar<M>} microgrammar
 * @param {(m: M) => void} action
 * @param {{makeUpdatable: boolean}} opts
 */
export declare function doWithUniqueMatch<M, P extends ProjectAsync = ProjectAsync>(p: P, globPattern: string, microgrammar: Microgrammar<M>, action: (m: M) => void, opts?: Opts): Promise<P>;
/**
 * Similar to doWithUniqueMatch, but accepts zero matches without error
 * @param p project
 * @param {string} globPattern
 * @param {Microgrammar<M>} microgrammar
 * @param {(m: M) => void} action
 * @param {{makeUpdatable: boolean}} opts
 */
export declare function doWithAtMostOneMatch<M, P extends ProjectAsync = ProjectAsync>(p: P, globPattern: string, microgrammar: Microgrammar<M>, action: (m: M) => void, opts?: Opts): Promise<P>;
