"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const minimatch = require("minimatch");
const spigot = require("stream-spigot");
const File_1 = require("../File");
const AbstractProject_1 = require("../support/AbstractProject");
const projectUtils_1 = require("../support/projectUtils");
const InMemoryFile_1 = require("./InMemoryFile");
/**
 * In memory Project implementation. Primarily intended
 * for testing. BE WARNED: Does not correctly handle permissions and binary files!
 */
class InMemoryProject extends AbstractProject_1.AbstractProject {
    constructor(xid) {
        super(xid);
        /**
         * Directories added. May contain no files. Must
         * be included when copying to a file system.
         * @type {Array}
         */
        this.addedDirectoryPaths = [];
        this.memFiles = [];
    }
    /**
     * Create a new InMemoryProject
     * @param id: RepoRef
     * @param files files to include in the project
     * @return {InMemoryProject}
     */
    static from(id, ...files) {
        const inp = new InMemoryProject(id);
        files.forEach(f => inp.recordAddFile(f.path, File_1.isFile(f) ? f.getContentSync() : f.content));
        return inp;
    }
    /**
     * Create a new InMemoryProject without an id
     */
    static of(...files) {
        return InMemoryProject.from(undefined, ...files);
    }
    /**
     * Make an independent copy of the given project, with the same files
     * @param {Project} p
     * @return {InMemoryProject}
     */
    static cache(p) {
        const to = new InMemoryProject(p.id);
        return projectUtils_1.copyFiles(p, to);
    }
    get fileCount() {
        return this.memFiles.length;
    }
    get filesSync() {
        return this.memFiles;
    }
    findFile(path) {
        const file = this.memFiles.find(f => f.path === path);
        return file ? Promise.resolve(file) : Promise.reject(`File not found at ${path}`);
    }
    getFile(path) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.memFiles.find(f => f.path === path);
        });
    }
    findFileSync(path) {
        return this.memFiles.find(f => f.path === path);
    }
    recordAddFile(path, content) {
        this.memFiles.push(new InMemoryFile_1.InMemoryFile(path, content));
        return this;
    }
    addFileSync(path, content) {
        this.recordAddFile(path, content);
    }
    addFile(path, content) {
        this.addFileSync(path, content);
        return Promise.resolve(this);
    }
    addDirectory(path) {
        this.addedDirectoryPaths.push(path);
        return Promise.resolve(this);
    }
    deleteDirectorySync(path) {
        this.memFiles.forEach(f => {
            if (f.path.startsWith(`${path}/`)) {
                this.deleteFileSync(f.path);
            }
        });
    }
    deleteDirectory(path) {
        this.deleteDirectorySync(path);
        return Promise.resolve(this);
    }
    deleteFileSync(path) {
        this.memFiles = this.memFiles.filter(f => f.path !== path);
        return this;
    }
    deleteFile(path) {
        this.deleteFileSync(path);
        return Promise.resolve(this);
    }
    makeExecutableSync(path) {
        throw new Error("unimplemented: makeExecutableSync");
    }
    directoryExistsSync(path) {
        return this.memFiles.some(f => f.path.startsWith(`${path}/`));
    }
    fileExistsSync(path) {
        return this.memFiles.some(f => f.path === path);
    }
    streamFilesRaw(globPatterns) {
        // TODO allow more than one glob pattern
        // if (globPatterns.length !== 0) {
        //     throw new Error("Only one glob pattern supported");
        // }
        const matchingPaths = minimatch.match(this.memFiles.map(f => f.path), globPatterns[0]);
        this.memFiles.map(f => matchingPaths.includes(f.path));
        return spigot.array({ objectMode: true }, this.memFiles.filter(f => matchingPaths.some(mp => mp === f.path)));
    }
    makeExecutable(path) {
        throw new Error("makeExecutable not implemented.");
    }
}
exports.InMemoryProject = InMemoryProject;
function isInMemoryProject(p) {
    const maybe = p;
    return maybe.addedDirectoryPaths !== undefined;
}
exports.isInMemoryProject = isInMemoryProject;
//# sourceMappingURL=InMemoryProject.js.map