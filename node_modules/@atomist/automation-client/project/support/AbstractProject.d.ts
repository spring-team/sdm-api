import { AbstractScriptedFlushable } from "../../internal/common/AbstractScriptedFlushable";
import { RepoRef } from "../../operations/common/RepoId";
import { File, FileNonBlocking } from "../File";
import { FileStream, Project } from "../Project";
/**
 * Support for implementations of Project interface
 */
export declare abstract class AbstractProject extends AbstractScriptedFlushable<Project> implements Project {
    id: RepoRef;
    readonly name: string;
    constructor(id: RepoRef);
    /**
     * Return the file, or reject with error
     * @param {string} path
     * @return {Promise<File>}
     */
    abstract findFile(path: string): Promise<File>;
    abstract getFile(path: string): Promise<File | undefined>;
    abstract findFileSync(path: string): File;
    streamFiles(...globPatterns: string[]): FileStream;
    abstract streamFilesRaw(globPatterns: string[], opts: {}): FileStream;
    totalFileCount(): Promise<number>;
    trackFile(f: FileNonBlocking): this;
    moveFile(oldPath: string, newPath: string): Promise<this>;
    abstract makeExecutable(path: string): Promise<this>;
    recordAddFile(path: string, content: string): this;
    recordDeleteFile(path: string): this;
    abstract addFileSync(path: string, content: string): void;
    abstract deleteDirectorySync(path: string): void;
    abstract deleteDirectory(path: string): Promise<this>;
    add(f: File): Promise<this>;
    abstract addFile(path: string, content: string): Promise<this>;
    abstract addDirectory(path: string): Promise<this>;
    abstract deleteFile(path: string): Promise<this>;
    abstract deleteFileSync(path: string): void;
    abstract makeExecutableSync(path: string): void;
    abstract directoryExistsSync(path: string): boolean;
    abstract fileExistsSync(path: string): boolean;
}
