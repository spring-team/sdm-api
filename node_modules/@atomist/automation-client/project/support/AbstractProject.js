"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AbstractScriptedFlushable_1 = require("../../internal/common/AbstractScriptedFlushable");
const logger_1 = require("../../internal/util/logger");
const fileGlobs_1 = require("../fileGlobs");
/**
 * Support for implementations of Project interface
 */
class AbstractProject extends AbstractScriptedFlushable_1.AbstractScriptedFlushable {
    constructor(id) {
        super();
        this.id = id;
    }
    get name() {
        return !!this.id ? this.id.repo : undefined;
    }
    streamFiles(...globPatterns) {
        const globsToUse = globPatterns.length > 0 ? globPatterns.concat(fileGlobs_1.DefaultExcludes) : fileGlobs_1.DefaultFiles;
        return this.streamFilesRaw(globsToUse, {});
    }
    totalFileCount() {
        return new Promise((resolve, reject) => {
            let count = 0;
            this.streamFiles()
                .on("data", f => count++)
                .on("error", reject)
                .on("end", _ => resolve(count));
        });
    }
    trackFile(f) {
        logger_1.logger.debug(`Project is tracking '${f.path}'`);
        return this.recordAction(p => {
            return f.flush().then(_ => p);
        });
    }
    moveFile(oldPath, newPath) {
        return this.findFile(oldPath)
            .then(f => f.setPath(newPath).then(() => this))
            // Not an error if no such file
            .catch(err => this);
    }
    recordAddFile(path, content) {
        return this.recordAction(p => p.addFile(path, content));
    }
    recordDeleteFile(path) {
        return this.recordAction(p => p.deleteFile(path));
    }
    // TODO set permissions
    add(f) {
        return f.getContent()
            .then(content => this.addFile(f.path, content));
    }
}
exports.AbstractProject = AbstractProject;
//# sourceMappingURL=AbstractProject.js.map