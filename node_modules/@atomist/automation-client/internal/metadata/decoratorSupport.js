"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const scan_1 = require("../../scan");
function set_metadata(obj, key, value) {
    let target = obj;
    if (obj.prototype !== undefined) {
        // should only be true for class Decorators
        target = obj.prototype;
    }
    Object.defineProperty(target, key, {
        value,
        writable: false,
        enumerable: false,
        configurable: false,
    });
}
function get_metadata(obj, key) {
    if (obj == null) {
        return null;
    }
    let desc = Object.getOwnPropertyDescriptor(obj, key);
    if ((desc == null || desc === undefined) && (Object.getPrototypeOf(obj) !== undefined)) {
        desc = get_metadata(Object.getPrototypeOf(obj), key);
    }
    if (desc != null && desc !== undefined) {
        return desc.value;
    }
    return null;
}
function declareParameter(target, propertyKey, details) {
    let params = get_metadata(target, "__parameters");
    if (params == null) {
        params = [];
    }
    else {
        // remove any that have the same name already (i.e. if folk are calling declareParameter)
        // use a cheeky method so that we can reuse the same array
        const found = params.filter(p => p.name === propertyKey);
        if (found != null && found.length > 0) {
            const index = params.indexOf(found[0]);
            params.splice(index, 1);
        }
    }
    const copy = Object.assign({}, details);
    // Make required = true the default
    copy.required = (copy.required !== undefined) ? copy.required : true;
    copy.name = propertyKey;
    params.push(copy);
    // merge parameters from parent if it has some
    let parent = Object.getPrototypeOf(target);
    while (parent != null) {
        const protoParams = get_metadata(parent, "__parameters");
        if (protoParams != null) {
            protoParams.forEach(protoParam => {
                // if we don't already have a parameter with the same name
                if (!params.some(param => param.name === protoParam.name)) {
                    params.push(protoParam);
                }
            });
        }
        parent = Object.getPrototypeOf(parent);
    }
    set_metadata(target, "__parameters", params);
    return target;
}
exports.declareParameter = declareParameter;
function declareMappedParameter(target, name, uri, required) {
    let params = get_metadata(target, "__mappedParameters");
    if (params == null) {
        params = [];
    }
    else {
        // remove any that have the same name already (i.e. if folk are calling declareMappedParameter)
        // use a cheeky method so that we can reuse the same array
        const found = params.filter(p => p.localKey === name);
        if (found != null && found.length > 0) {
            const index = params.indexOf(found[0]);
            params.splice(index, 1);
        }
    }
    const param = { name, uri, required };
    params.push(param);
    // merge mapped_parameters from parent if it has some
    let parent = Object.getPrototypeOf(target);
    while (parent != null) {
        const protoParams = get_metadata(parent, "__mappedParameters");
        if (protoParams != null) {
            protoParams.forEach(protoParam => {
                // if we don't already have a parameter with the same name
                if (!params.some(p => p.name === protoParam.name)) {
                    params.push(protoParam);
                }
            });
        }
        parent = Object.getPrototypeOf(parent);
    }
    set_metadata(target, "__mappedParameters", params);
    return target;
}
exports.declareMappedParameter = declareMappedParameter;
function declareValue(target, name, value) {
    let params = get_metadata(target, "__values");
    if (params == null) {
        params = [];
    }
    else {
        // remove any that have the same name already (i.e. if folk are calling declareValue)
        // use a cheeky method so that we can reuse the same array
        const found = params.filter(p => p.localKey === name);
        if (found != null && found.length > 0) {
            const index = params.indexOf(found[0]);
            params.splice(index, 1);
        }
    }
    const param = { name, value };
    params.push(param);
    // merge values from parent if it has some
    let parent = Object.getPrototypeOf(target);
    while (parent != null) {
        const protoParams = get_metadata(parent, "__values");
        if (protoParams != null) {
            protoParams.forEach(protoParam => {
                // if we don't already have a value with the same name
                if (!params.some(p => p.name === protoParam.name)) {
                    params.push(protoParam);
                }
            });
        }
        parent = Object.getPrototypeOf(parent);
    }
    set_metadata(target, "__values", params);
    return target;
}
exports.declareValue = declareValue;
function declareSecret(target, name, uri) {
    let params = get_metadata(target, "__secrets");
    if (params == null) {
        params = [];
    }
    else {
        // remove any that have the same name already (i.e. if folk are calling declareSecret)
        // use a cheeky method so that we can reuse the same array
        const found = params.filter(p => p.name === name);
        if (found != null && found.length > 0) {
            const index = params.indexOf(found[0]);
            params.splice(index, 1);
        }
    }
    const param = { name, uri };
    params.push(param);
    // merge secrets from parent if it has some
    let parent = Object.getPrototypeOf(target);
    while (parent != null) {
        const protoParams = get_metadata(parent, "__secrets");
        if (protoParams != null) {
            protoParams.forEach(protoParam => {
                // if we don't already have a parameter with the same name
                if (!params.some(p => p.name === protoParam.name)) {
                    params.push(protoParam);
                }
            });
        }
        parent = Object.getPrototypeOf(parent);
    }
    set_metadata(target, "__secrets", params);
    return target;
}
exports.declareSecret = declareSecret;
function declareCommandHandler(obj, description, autoSubmit, intent) {
    declareRug(obj, "command-handler", description);
    declareIntent(obj, intent);
    if (autoSubmit) {
        declareAutoSubmit(obj, autoSubmit);
    }
    scan_1.registerCommand(obj);
    return obj;
}
exports.declareCommandHandler = declareCommandHandler;
function declareParameters(obj) {
    set_metadata(obj, "__name", obj.prototype.constructor.name);
    set_metadata(obj, "__kind", "parameters");
    return obj;
}
exports.declareParameters = declareParameters;
function declareRug(obj, kind, description) {
    set_metadata(obj, "__description", description);
    set_metadata(obj, "__name", obj.prototype.constructor.name);
    set_metadata(obj, "__kind", kind);
}
function declareEventHandler(obj, description, subscription) {
    declareRug(obj, "event-handler", description);
    set_metadata(obj, "__subscription", subscription);
    scan_1.registerEvent(obj);
    return obj;
}
exports.declareEventHandler = declareEventHandler;
function declareTags(target, tags) {
    set_metadata(target, "__tags", tags.map(t => ({ name: t, description: t })));
    return target;
}
exports.declareTags = declareTags;
function declareIntent(target, intent) {
    set_metadata(target, "__intent", intent);
    return target;
}
exports.declareIntent = declareIntent;
function declareAutoSubmit(target, autoSubmit) {
    set_metadata(target, "__autoSubmit", autoSubmit);
    return target;
}
exports.declareAutoSubmit = declareAutoSubmit;
//# sourceMappingURL=decoratorSupport.js.map