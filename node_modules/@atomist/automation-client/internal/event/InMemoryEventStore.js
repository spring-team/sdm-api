"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lru_map_1 = require("lru_map");
const string_1 = require("../util/string");
/**
 * Simple {EventStore} implementation that stores events in memory.
 */
class InMemoryEventStore {
    constructor() {
        // 5 mins for 3 hours
        this.eventSer = new RRD(60 * 5, 12 * 3);
        this.commandSer = new RRD(60 * 5, 12 * 3);
        this.eventCache = new lru_map_1.LRUMap(100);
        this.commandCache = new lru_map_1.LRUMap(100);
        this.messageCache = new lru_map_1.LRUMap(100);
    }
    recordEvent(event) {
        const id = event.extensions.correlation_id ? event.extensions.correlation_id : string_1.guid();
        this.eventCache.set({ guid: id, correlationId: id, ts: new Date().getTime() }, event);
        this.eventSer.update(1);
        return id;
    }
    recordCommand(command) {
        const id = command.correlation_id ? command.correlation_id : string_1.guid();
        this.commandCache.set({ guid: id, correlationId: id, ts: new Date().getTime() }, command);
        this.commandSer.update(1);
        return id;
    }
    recordMessage(id, correlationId, message) {
        this.messageCache.set({ guid: id, correlationId, ts: new Date().getTime() }, message);
        return id;
    }
    events(from = -1) {
        const entries = [];
        this.eventCache.forEach((v, k) => k.ts > from ? entries.push({ key: k, value: hideSecrets(v) }) : null);
        return entries;
    }
    eventSeries() {
        const buckets = this.eventSer.fetch().filter(b => b.ts);
        return [buckets.map(b => b.value), buckets.map(b => b.ts)];
    }
    commands(from = -1) {
        const entries = [];
        this.commandCache.forEach((v, k) => k.ts > from ? entries.push({ key: k, value: hideSecrets(v) }) : null);
        return entries;
    }
    commandSeries() {
        const buckets = this.commandSer.fetch().filter(b => b.ts);
        return [buckets.map(b => b.value), buckets.map(b => b.ts)];
    }
    messages(from = -1) {
        const entries = [];
        this.messageCache.forEach((v, k) => k.ts > from ? entries.push({ key: k, value: v }) : null);
        return entries;
    }
}
exports.InMemoryEventStore = InMemoryEventStore;
function hideSecrets(event) {
    event.secrets = event.secrets
        ? event.secrets.map(s => ({ uri: s.uri, value: string_1.hideString(s.value) })) : undefined;
    return event;
}
class Count {
    constructor() {
        this.value = 0;
    }
    update(data) {
        this.value++;
        return this.value;
    }
    result() {
        const value = this.value;
        this.value = 0;
        return value;
    }
}
class RRD {
    constructor(interval, count) {
        this.dataFunc = new Count();
        this.buckets = new Array(count).fill(0);
        this.buckets[0] = { ts: Math.floor(Date.now() / 1000), value: 0 };
        this.index = 1;
        this.interval = interval * 1000;
        this.iid = setInterval(this.increment.bind(this), this.interval);
    }
    increment() {
        if (this.index < this.buckets.length) {
            this.buckets[this.index] = { ts: Math.floor(Date.now() / 1000), value: this.dataFunc.result() };
            this.index += 1;
        }
        else {
            this.buckets.push({ ts: Math.floor(Date.now() / 1000), value: this.dataFunc.result() });
            this.buckets.shift();
        }
    }
    update(data) {
        this.buckets[this.index] = { ts: Math.floor(Date.now() / 1000), value: this.dataFunc.update(data) };
    }
    fetch() {
        return this.buckets;
    }
}
//# sourceMappingURL=InMemoryEventStore.js.map