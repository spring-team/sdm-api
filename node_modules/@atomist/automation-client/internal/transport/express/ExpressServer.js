"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GitHubApi = require("@octokit/rest");
const bodyParser = require("body-parser");
const express = require("express");
const passport = require("passport");
const http = require("passport-http");
const bearer = require("passport-http-bearer");
const tokenHeader = require("passport-http-header-token");
const retry = require("retry");
const globals = require("../../../globals");
const globals_1 = require("../../../globals");
const health_1 = require("../../util/health");
const info_1 = require("../../util/info");
const logger_1 = require("../../util/logger");
const memory_1 = require("../../util/memory");
const metric_1 = require("../../util/metric");
const string_1 = require("../../util/string");
const payloads_1 = require("../websocket/payloads");
const ExpressRequestProcessor_1 = require("./ExpressRequestProcessor");
/**
 * Registers an endpoint for every automation and exposes
 * metadataFromInstance at root. Responsible for marshalling into the appropriate structure
 */
class ExpressServer {
    constructor(automations, listeners = [], options) {
        this.automations = automations;
        this.listeners = listeners;
        this.options = options;
        this.adminRoute = (req, res, next) => {
            req.__admin = true;
            next();
        };
        this.authenticate = (req, res, next) => {
            if (this.options.auth) {
                const strategies = [];
                if (this.options.auth.bearer && this.options.auth.bearer.enabled === true) {
                    strategies.push("bearer");
                }
                if (this.options.auth.basic && this.options.auth.basic.enabled === true) {
                    strategies.push("basic");
                }
                if (this.options.auth.token && this.options.auth.token.enabled === true) {
                    strategies.push("token");
                }
                if (strategies.length > 0) {
                    passport.authenticate(strategies, { session: false })(req, res, next);
                }
                else {
                    next();
                }
            }
            else {
                next();
            }
        };
        const exp = express();
        exp.use(bodyParser.json());
        exp.use(require("helmet")());
        exp.use(passport.initialize());
        // Enable cors for all endpoints
        const cors = require("cors");
        exp.options("*", cors());
        this.setupAuthentication();
        // Set up routes
        exp.get(`${ApiBase}/health`, cors(), (req, res) => {
            const h = health_1.health();
            res.status(h.status === health_1.HealthStatus.Up ? 200 : 500).json(h);
        });
        exp.get(`${ApiBase}/info`, cors(), this.adminRoute, this.authenticate, (req, res) => {
            res.json(info_1.info(automations.automations));
        });
        exp.get(`${ApiBase}/registration`, cors(), this.adminRoute, this.authenticate, (req, res) => {
            res.json(payloads_1.prepareRegistration(automations.automations));
        });
        exp.get(`${ApiBase}/metrics`, cors(), this.adminRoute, this.authenticate, (req, res) => {
            res.json(metric_1.metrics());
        });
        exp.put(`${ApiBase}/memory/gc`, cors(), this.adminRoute, this.authenticate, (req, res) => {
            memory_1.gc();
            res.sendStatus(201);
        });
        exp.put(`${ApiBase}/memory/heapdump`, cors(), this.adminRoute, this.authenticate, (req, res) => {
            memory_1.heapDump();
            res.sendStatus(201);
        });
        exp.get(`${ApiBase}/log/events`, cors(), this.adminRoute, this.authenticate, (req, res) => {
            res.json(globals.eventStore().events(req.query.from));
        });
        exp.get(`${ApiBase}/log/commands`, cors(), this.adminRoute, this.authenticate, (req, res) => {
            res.json(globals.eventStore().commands(req.query.from));
        });
        exp.get(`${ApiBase}/log/messages`, cors(), this.adminRoute, this.authenticate, (req, res) => {
            res.json(globals.eventStore().messages(req.query.from));
        });
        exp.get(`${ApiBase}/series/events`, cors(), this.adminRoute, this.authenticate, (req, res) => {
            res.json(globals.eventStore().eventSeries());
        });
        exp.get(`${ApiBase}/series/commands`, cors(), this.adminRoute, this.authenticate, (req, res) => {
            res.json(globals.eventStore().commandSeries());
        });
        this.exposeCommandHandlerInvocationRoute(exp, `${ApiBase}/command`, cors, (req, res, result) => {
            if (result.redirect && !req.get("x-atomist-no-redirect")) {
                res.redirect(result.redirect);
            }
            else {
                res.status(result.code === 0 ? 200 : 500).json(result);
            }
        });
        this.exposeEventHandlerInvocationRoute(exp, `${ApiBase}/event`, cors, (req, res, result) => {
            res.status(result.some(r => r.code !== 0) ? 500 : 200).json(result);
        });
        if (this.options.customizers.length > 0) {
            logger_1.logger.debug("Invoking http server customizers");
            this.options.customizers.forEach(c => c(exp, this.authenticate));
        }
        const operation = retry.operation({
            retries: 100,
            factor: 3,
            minTimeout: 1 * 1000,
            maxTimeout: 5 * 1000,
            randomize: true,
        });
        operation.attempt(() => {
            exp.listen(this.options.port, () => {
                logger_1.logger.debug(`Atomist automation client api running at 'http://${this.options.host}:${this.options.port}'`);
            }).on("error", err => {
                logger_1.logger.warn("Starting automation client api failed: %s", err.message);
                if (operation.retry(err)) {
                    return;
                }
                else {
                    logger_1.logger.error("Failed to start automation client api");
                }
            });
        });
    }
    exposeCommandHandlerInvocationRoute(exp, url, cors, handle) {
        exp.post(url, cors(), this.authenticate, (req, res) => {
            const handler = new ExpressRequestProcessor_1.ExpressRequestProcessor(globals_1.automationClientInstance().configuration.token, this.automations, this.listeners, this.options);
            handler.processCommand(req.body, result => {
                result.then(r => handle(req, res, r));
            });
        });
    }
    exposeEventHandlerInvocationRoute(exp, url, cors, handle) {
        exp.post(url, cors(), this.authenticate, (req, res) => {
            const handler = new ExpressRequestProcessor_1.ExpressRequestProcessor(globals_1.automationClientInstance().configuration.token, this.automations, this.listeners, this.options);
            handler.processEvent(req.body, result => {
                result.then(r => handle(req, res, r));
            });
        });
    }
    setupAuthentication() {
        if (this.options.auth && this.options.auth.basic && this.options.auth.basic.enabled) {
            const user = this.options.auth.basic.username ? this.options.auth.basic.username : "admin";
            const pwd = this.options.auth.basic.password ? this.options.auth.basic.password : string_1.guid();
            passport.use("basic", new http.BasicStrategy((username, password, done) => {
                if (user === username && pwd === password) {
                    done(null, { user: username });
                }
                else {
                    done(null, false);
                }
            }));
            if (!this.options.auth.basic.password) {
                logger_1.logger.info(`Auto-generated credentials for web endpoints are user '${user}' and password '${pwd}'`);
            }
        }
        if (this.options.auth && this.options.auth.bearer && this.options.auth.bearer.enabled) {
            const org = this.options.auth.bearer.org;
            const adminOrg = this.options.auth.bearer.adminOrg;
            passport.use("bearer", new bearer.Strategy({
                passReqToCallback: true,
            }, (req, token, done) => {
                const api = new GitHubApi();
                api.authenticate({ type: "token", token });
                api.users.get({})
                    .then(user => {
                    if (adminOrg && req.__admin === true) {
                        return api.orgs.checkMembership({
                            username: user.data.login,
                            org: adminOrg,
                        })
                            .then(() => {
                            return user.data;
                        });
                    }
                    else if (org) {
                        return api.orgs.checkMembership({
                            username: user.data.login,
                            org,
                        })
                            .then(() => {
                            return user.data;
                        });
                    }
                    else {
                        return user.data;
                    }
                })
                    .then(user => {
                    return done(null, { token, user });
                })
                    .catch(err => {
                    console.log(err);
                    return done(null, false);
                });
            }));
        }
        if (this.options.auth && this.options.auth.token && this.options.auth.token.enabled) {
            const cb = this.options.auth.token.verify || (token => Promise.resolve(false));
            passport.use("token", new tokenHeader.Strategy((token, done) => {
                cb(token)
                    .then(valid => {
                    if (valid) {
                        return done(null, { user: token });
                    }
                    else {
                        return done(null, false);
                    }
                })
                    .catch(err => {
                    console.log(err);
                    return done(null, false);
                });
            }));
        }
    }
}
exports.ExpressServer = ExpressServer;
const ApiBase = "";
//# sourceMappingURL=ExpressServer.js.map