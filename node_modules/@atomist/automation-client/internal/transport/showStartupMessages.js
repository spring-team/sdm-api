"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const util_1 = require("util");
const globals_1 = require("../../globals");
const info_1 = require("../util/info");
const logger_1 = require("../util/logger");
const OnLog_1 = require("./OnLog");
/**
 * Build and log startup message, including any user banner
 * @param {RegistrationConfirmation} registration
 * @param {Automations} automations
 */
function showStartupMessages(registration, automations) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!globals_1.automationClientInstance()) {
            return;
        }
        const chalk = require("chalk");
        let message = automations.name;
        const b = _.get(globals_1.automationClientInstance(), "configuration.logging.banner");
        if (typeof b === "string") {
            message = chalk.green(yield toAscii(b));
        }
        else if (b === true) {
            message = chalk.green(yield toAscii(message));
        }
        else if (_.isFunction(b)) {
            // It's a function returning a banner object
            const banner = b(registration);
            message = chalk[banner.color](banner.asciify ? yield toAscii(banner.banner) : banner.banner);
        }
        else if (b === false) {
            return;
        }
        const gitInfo = info_1.info(automations);
        const urls = automations.team_ids.map(t => {
            return `
  ${chalk.grey("Url")} ${chalk.underline(`https://app.atomist.com/workspace/${t}/automations`)}
  ${chalk.grey("GraphiQL")} ${chalk.underline(`https://app.atomist.com/workspace/${t}/graphql`)}`;
        });
        const commands = automations.commands
            .sort((c1, c2) => c1.name.localeCompare(c2.name))
            .map(c => `    ${c.name} ${c.description ? `(${_.upperFirst(c.description)})` : ""}`);
        const events = automations.events
            // filter internal atomist log event handler
            .filter(e => e.name !== OnLog_1.OnLogName)
            .sort((e1, e2) => e1.name.localeCompare(e2.name))
            .map(e => `    ${e.name} ${e.description ? `(${_.upperFirst(e.description)})` : ""}`);
        /* tslint:disable */
        const msg = `
${message}
  ${chalk.grey("Version")} ${automations.version}${gitInfo.git ? `  ${chalk.grey("Sha")} ${gitInfo.git.sha.slice(0, 7)}  ${chalk.grey("Repository")} ${gitInfo.git.repository}` : ""}
  ${automations.groups && automations.groups.length > 0 ? `${chalk.grey("Groups")} all` : `${chalk.grey(`${automations.team_ids.length > 1 ? "Teams" : "Team"}`)} ${automations.team_ids.join(", ")}`}  ${chalk.grey("Policy")} ${automations.policy ? automations.policy : "ephemeral"}  ${chalk.grey("Cluster")} ${globals_1.automationClientInstance().configuration.cluster.enabled ? "enabled" : "disabled"}
  ${chalk.grey(commands.length === 1 ? "Command" : "Commands")} ${commands.length}  ${chalk.grey(events.length === 1 ? "Event" : "Events")} ${events.length}  ${chalk.grey(automations.ingesters.length === 1 ? "Ingester" : "Ingesters")} ${automations.ingesters.length}
  ${chalk.grey("JWT")} ${registration.jwt}
  ${commands.length > 0 ? `
  ${chalk.grey(commands.length === 1 ? "Command" : "Commands")}
${commands.join("\n")}` : ""}
  ${events.length > 0 ? `
  ${chalk.grey(events.length === 1 ? "Event" : "Events")}
${events.join("\n")}` : ""}
${urls.join("\n")}
${urls.length > 0 ? "\n" : ""}  ${chalk.grey("Docs")} https://docs.atomist.com  ${chalk.grey("Support")} https://join.atomist.com
`;
        /* tslint:enable */
        logger_1.logger.info(msg);
    });
}
exports.showStartupMessages = showStartupMessages;
function toAscii(s) {
    return __awaiter(this, void 0, void 0, function* () {
        const asciify = require("asciify");
        const promisified = util_1.promisify(asciify);
        try {
            return promisified(s, { font: "ogre" });
        }
        catch (_a) {
            return s;
        }
    });
}
//# sourceMappingURL=showStartupMessages.js.map