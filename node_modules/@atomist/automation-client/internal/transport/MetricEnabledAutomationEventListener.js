"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AutomationEventListener_1 = require("../../server/AutomationEventListener");
const metric_1 = require("../util/metric");
class MetricEnabledAutomationEventListener extends AutomationEventListener_1.AutomationEventListenerSupport {
    commandSuccessful(payload, ctx, result) {
        const start = ctx.context.ts;
        metric_1.duration(`command_handler.${payload.name}.success`, Date.now() - start);
        metric_1.duration(`command_handler.global`, Date.now() - start);
        return Promise.resolve();
    }
    commandFailed(payload, ctx, err) {
        const start = ctx.context.ts;
        metric_1.duration(`command_handler.${payload.name}.failure`, Date.now() - start);
        metric_1.duration(`command_handler.global`, Date.now() - start);
        return Promise.resolve();
    }
    eventSuccessful(payload, ctx, result) {
        const start = ctx.context.ts;
        metric_1.duration(`event_handler.${payload.extensions.operationName}.success`, Date.now() - start);
        metric_1.duration(`event_handler.global`, Date.now() - start);
        return Promise.resolve();
    }
    eventFailed(payload, ctx, err) {
        const start = ctx.context.ts;
        metric_1.duration(`event_handler.${payload.extensions.operationName}.failure`, Date.now() - start);
        metric_1.duration(`event_handler.global`, Date.now() - start);
        return Promise.resolve();
    }
}
exports.MetricEnabledAutomationEventListener = MetricEnabledAutomationEventListener;
//# sourceMappingURL=MetricEnabledAutomationEventListener.js.map