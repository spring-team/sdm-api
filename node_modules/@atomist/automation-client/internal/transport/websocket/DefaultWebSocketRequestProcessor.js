"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const stringify = require("json-stringify-safe");
const global = require("../../../globals");
const health_1 = require("../../util/health");
const logger_1 = require("../../util/logger");
const AbstractRequestProcessor_1 = require("../AbstractRequestProcessor");
const RequestProcessor_1 = require("../RequestProcessor");
const showStartupMessages_1 = require("../showStartupMessages");
const GraphClientFactory_1 = require("./GraphClientFactory");
const WebSocketMessageClient_1 = require("./WebSocketMessageClient");
class DefaultWebSocketRequestProcessor extends AbstractRequestProcessor_1.AbstractRequestProcessor {
    constructor(automations, options, listeners = []) {
        super(automations, listeners);
        this.automations = automations;
        this.options = options;
        this.listeners = listeners;
        health_1.registerHealthIndicator(() => {
            if (this.webSocket && this.registration) {
                return { status: health_1.HealthStatus.Up, detail: "WebSocket connection established" };
            }
            else {
                return { status: health_1.HealthStatus.Down, detail: "WebSocket disconnected" };
            }
        });
    }
    onRegistration(registration) {
        logger_1.logger.info("Registration successful: %s", stringify(registration));
        global.setJwtToken(registration.jwt);
        this.registration = registration;
        this.graphClients = new GraphClientFactory_1.GraphClientFactory(this.registration, this.options);
        showStartupMessages_1.showStartupMessages(registration, this.automations.automations)
            .then(() => {
            // intentionally left empty
        });
    }
    onConnect(ws) {
        logger_1.logger.info("WebSocket connection established. Listening for incoming messages");
        this.webSocket = ws;
        this.listeners.forEach(l => l.registrationSuccessful(this));
    }
    onDisconnect() {
        this.webSocket = null;
        this.registration = null;
    }
    sendStatusMessage(payload, ctx) {
        return Promise.resolve(WebSocketMessageClient_1.sendMessage(payload, this.webSocket));
    }
    createGraphClient(event) {
        return this.graphClients.createGraphClient(event);
    }
    createMessageClient(event) {
        if (RequestProcessor_1.isCommandIncoming(event)) {
            return new WebSocketMessageClient_1.WebSocketCommandMessageClient(event, this.webSocket);
        }
        else if (RequestProcessor_1.isEventIncoming(event)) {
            return new WebSocketMessageClient_1.WebSocketEventMessageClient(event, this.webSocket);
        }
    }
}
exports.DefaultWebSocketRequestProcessor = DefaultWebSocketRequestProcessor;
//# sourceMappingURL=DefaultWebSocketRequestProcessor.js.map