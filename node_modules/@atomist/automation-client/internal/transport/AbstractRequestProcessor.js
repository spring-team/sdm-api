"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const stringify = require("json-stringify-safe");
const _ = require("lodash");
const serializeError = require("serialize-error");
const HandlerResult_1 = require("../../HandlerResult");
const MessageClientSupport_1 = require("../../spi/message/MessageClientSupport");
const disposable_1 = require("../invoker/disposable");
const namespace = require("../util/cls");
const logger_1 = require("../util/logger");
const string_1 = require("../util/string");
class AbstractRequestProcessor {
    constructor(automations, listeners = []) {
        this.automations = automations;
        this.listeners = listeners;
    }
    processCommand(command, 
    // tslint:disable-next-line:no-empty
    callback = () => { }) {
        // setup context
        const ses = namespace.init();
        const cls = this.setupNamespace(command, this.automations);
        ses.run(() => {
            namespace.set(cls);
            this.listeners.forEach(l => l.commandIncoming(command));
            const np = namespace.get();
            const ci = {
                name: command.command,
                args: command.parameters,
                mappedParameters: command.mapped_parameters,
                secrets: command.secrets,
            };
            const ctx = {
                teamId: command.team.id,
                source: command.source,
                correlationId: command.correlation_id,
                invocationId: np ? np.invocationId : undefined,
                messageClient: undefined,
                context: cls,
                trigger: command,
            };
            ctx.graphClient = this.createGraphClient(command, ctx);
            ctx.messageClient = this.createAndWrapMessageClient(command, ctx);
            ctx.lifecycle = {
                registerDisposable: disposable_1.registerDisposable(ctx),
                dispose: disposable_1.dispose(ctx),
            };
            this.listeners.forEach(l => l.contextCreated(ctx));
            this.listeners.forEach(l => l.commandStarting(ci, ctx));
            this.invokeCommand(ci, ctx, command, callback);
        });
    }
    processEvent(event, 
    // tslint:disable-next-line:no-empty
    callback = () => { }) {
        // setup context
        const ses = namespace.init();
        const cls = this.setupNamespace(event, this.automations);
        ses.run(() => {
            namespace.set(cls);
            this.listeners.forEach(l => l.eventIncoming(event));
            const np = namespace.get();
            const ef = {
                data: event.data,
                extensions: {
                    operationName: event.extensions.operationName,
                },
                secrets: event.secrets,
            };
            const ctx = {
                teamId: event.extensions.team_id,
                correlationId: event.extensions.correlation_id,
                invocationId: np ? np.invocationId : undefined,
                messageClient: undefined,
                context: cls,
                trigger: event,
            };
            ctx.graphClient = this.createGraphClient(event, ctx);
            ctx.messageClient = this.createAndWrapMessageClient(event, ctx);
            ctx.lifecycle = {
                registerDisposable: disposable_1.registerDisposable(ctx),
                dispose: disposable_1.dispose(ctx),
            };
            this.listeners.forEach(l => l.contextCreated(ctx));
            this.listeners.forEach(l => l.eventStarting(ef, ctx));
            this.invokeEvent(ef, ctx, event, callback);
        });
    }
    sendCommandStatus(success, code, request, ctx) {
        const source = _.cloneDeep(request.source);
        if (source && source.slack) {
            delete source.slack.user;
        }
        const response = {
            api_version: "1",
            correlation_id: request.correlation_id,
            team: request.team,
            command: request.command,
            source: request.source,
            destinations: [source],
            status: {
                code,
                reason: `${success ? "Successfully" : "Unsuccessfully"} invoked command` +
                    ` ${request.command} of ${this.automations.automations.name}@${this.automations.automations.version}`,
            },
        };
        return this.sendStatusMessage(response, ctx);
    }
    sendEventStatus(success, request, event, ctx) {
        const response = {
            api_version: "1",
            correlation_id: event.extensions.correlation_id,
            team: {
                id: event.extensions.team_id,
                name: event.extensions.team_name,
            },
            event: request.extensions.operationName,
            status: {
                code: success ? 0 : 1,
                reason: `${success ? "Successfully" : "Unsuccessfully"} invoked event subscription` +
                    ` ${request.extensions.operationName} of ${this.automations.automations.name}@${this.automations.automations.version}`,
            },
        };
        return this.sendStatusMessage(response, ctx);
    }
    invokeCommand(ci, ctx, command, callback) {
        const finalize = (result) => {
            this.sendCommandStatus(result.code === 0 ? true : false, result.code, command, ctx)
                .catch(err => logger_1.logger.warn("Unable to send status for command '%s': %s", command.command, err.message))
                .then(() => {
                callback(Promise.resolve(result));
                logger_1.logger.info(`Finished invocation of command '%s': %s`, command.command, stringify(result));
                this.clearNamespace();
            });
        };
        logger_1.logger.debug("Incoming command invocation '%s'", stringify(command, replacer));
        try {
            this.automations.invokeCommand(ci, ctx)
                .then(result => {
                if (!result || !result.hasOwnProperty("code")) {
                    return Object.assign({}, defaultResult(ctx), result);
                }
                else {
                    return result;
                }
            })
                .then(result => ctx.lifecycle ? ctx.lifecycle.dispose().then(() => result) : result)
                .then(result => {
                if (result.code === 0) {
                    result = Object.assign({}, defaultResult(ctx), result);
                    this.listeners.map(l => () => l.commandSuccessful(ci, ctx, result))
                        .reduce((p, f) => p.then(f), Promise.resolve())
                        .then(() => finalize(result));
                }
                else {
                    result = Object.assign({}, defaultErrorResult(ctx), result);
                    this.listeners.map(l => () => l.commandFailed(ci, ctx, result))
                        .reduce((p, f) => p.then(f), Promise.resolve())
                        .then(() => finalize(result));
                }
            })
                .catch(err => {
                this.handleCommandError(err, command, ci, ctx, callback);
            });
        }
        catch (err) {
            this.handleCommandError(err, command, ci, ctx, callback);
        }
    }
    invokeEvent(ef, ctx, event, callback) {
        const finalize = (results) => {
            this.sendEventStatus(results.some(r => r.code !== 0) ? false : true, ef, event, ctx)
                .catch(err => logger_1.logger.warn("Unable to send status for event subscription'%s': %s", event.extensions.operationName, err.message))
                .then(() => {
                callback(Promise.resolve(results));
                logger_1.logger.info(`Finished invocation of event subscription '%s': %s`, event.extensions.operationName, stringify(results));
                this.clearNamespace();
            });
        };
        logger_1.logger.debug("Incoming event subscription '%s'", stringify(event, replacer));
        try {
            this.automations.onEvent(ef, ctx)
                .then(result => {
                if (!result || result.length === 0) {
                    return [defaultResult(ctx)];
                }
                else {
                    return result;
                }
            })
                .then(result => ctx.lifecycle ? ctx.lifecycle.dispose().then(() => result) : result)
                .then(result => {
                if (!result.some(r => r.code !== 0)) {
                    this.listeners.map(l => () => l.eventSuccessful(ef, ctx, result))
                        .reduce((p, f) => p.then(f), Promise.resolve())
                        .then(() => finalize(result));
                }
                else {
                    this.listeners.map(l => () => l.eventFailed(ef, ctx, result))
                        .reduce((p, f) => p.then(f), Promise.resolve())
                        .then(() => finalize(result));
                }
            })
                .catch(err => {
                this.handleEventError(err, event, ef, ctx, callback);
            });
        }
        catch (err) {
            this.handleEventError(err, event, ef, ctx, callback);
        }
    }
    createAndWrapMessageClient(event, context) {
        return new MessageClientSupport_1.DefaultSlackMessageClient(new AutomationEventListenerEnabledMessageClient(context, this.createMessageClient(event, context), this.listeners), context.graphClient);
    }
    setupNamespace(request, automations, invocationId = string_1.guid(), ts = Date.now()) {
        return {
            correlationId: _.get(request, "correlation_id") || _.get(request, "extensions.correlation_id"),
            teamId: _.get(request, "team.id") || _.get(request, "extensions.team_id"),
            teamName: _.get(request, "team.name") || _.get(request, "extensions.team_name"),
            operation: _.get(request, "command") || _.get(request, "extensions.operationName"),
            name: automations.automations.name,
            version: automations.automations.version,
            invocationId,
            ts,
        };
    }
    clearNamespace() {
        namespace.set({
            correlationId: null,
            teamId: null,
            teamName: null,
            operation: null,
            name: null,
            version: null,
            invocationId: null,
            ts: null,
        });
    }
    handleCommandError(err, command, ci, ctx, callback) {
        const result = Object.assign({}, defaultErrorResult(ctx), HandlerResult_1.failure(err));
        this.listeners.map(l => () => l.commandFailed(ci, ctx, err))
            .reduce((p, f) => p.then(f), Promise.resolve())
            .then(() => {
            return this.sendCommandStatus(false, result.code, command, ctx)
                .then(() => {
                if (callback) {
                    callback(Promise.resolve(result));
                }
                logger_1.logger.error(`Failed invocation of command '%s'`, command.command, serializeError(err));
                this.clearNamespace();
            })
                .catch(error => logger_1.logger.warn("Unable to send status for command: " + stringify(command)));
        });
    }
    handleEventError(err, event, ef, ctx, callback) {
        const result = Object.assign({}, defaultErrorResult(ctx), HandlerResult_1.failure(err));
        this.listeners.map(l => () => l.eventFailed(ef, ctx, err))
            .reduce((p, f) => p.then(f), Promise.resolve())
            .then(() => {
            return this.sendEventStatus(false, ef, event, ctx)
                .then(() => {
                if (callback) {
                    callback(Promise.resolve(result));
                }
                logger_1.logger.error(`Failed invocation of event subscription '%s'`, event.extensions.operationName, serializeError(err));
                this.clearNamespace();
            })
                .catch(error => logger_1.logger.warn("Unable to send status for event subscription: " + stringify(event)));
        });
    }
}
exports.AbstractRequestProcessor = AbstractRequestProcessor;
class AutomationEventListenerEnabledMessageClient {
    constructor(ctx, delegate, listeners = []) {
        this.ctx = ctx;
        this.delegate = delegate;
        this.listeners = listeners;
    }
    respond(msg, options) {
        this.listeners.forEach(l => l.messageSent(msg, [], options, this.ctx));
        return this.delegate.respond(msg, options);
    }
    send(msg, destinations, options) {
        this.listeners.forEach(l => l.messageSent(msg, destinations, options, this.ctx));
        return this.delegate.send(msg, destinations, options);
    }
}
function defaultResult(context) {
    const result = {
        code: 0,
        correlation_id: context.context.correlationId,
        invocation_id: context.context.invocationId,
    };
    return result;
}
exports.defaultResult = defaultResult;
function defaultErrorResult(context) {
    const result = Object.assign({}, defaultResult(context), { code: 1, message: `Command '${context.context.operation}' failed` });
    return result;
}
exports.defaultErrorResult = defaultErrorResult;
function replacer(key, value) {
    if (key === "secrets" && value) {
        return value.map(v => ({ uri: v.uri, value: string_1.hideString(v.value) }));
    }
    else {
        return value;
    }
}
//# sourceMappingURL=AbstractRequestProcessor.js.map