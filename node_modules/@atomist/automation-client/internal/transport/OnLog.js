"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const graphQL_1 = require("../../graph/graphQL");
const HandlerResult_1 = require("../../HandlerResult");
const logger_1 = require("../util/logger");
// Subscription to retrieve all Log events for this automation client
const LogSubscription = `subscription OnLog($name: String!, $version: String!) {
  AtomistLog {
    level
    timestamp
    message
    correlation_context @required {
      correlation_id
      automation(name: $name, version: $version) @required {
        name
        version
      }
    }
  }
}`;
exports.OnLogName = "OnLog";
/**
 * Subscribe to AtomistLog events from the API.
 * Note: This event handler will get registered when this is enabled in the automation client configuration
 */
class OnLog {
    constructor(eman, version, logHandlers = [ConsoleLogHandler]) {
        this.eman = eman;
        this.version = version;
        this.logHandlers = logHandlers;
        this.name = exports.OnLogName;
        this.description = "Subscribe to AtomistLog events from the API";
        this.subscriptionName = exports.OnLogName;
        this.subscription = graphQL_1.subscription({
            subscription: LogSubscription,
            variables: {
                name: eman,
                version,
            },
            inline: true,
        });
    }
    handle(e, ctx) {
        return __awaiter(this, void 0, void 0, function* () {
            const log = e.data.AtomistLog[0];
            for (const logHandler of this.logHandlers) {
                yield logHandler(log, ctx);
            }
            return HandlerResult_1.Success;
        });
    }
}
exports.OnLog = OnLog;
/**
 * Maker that gets registered to subscribe to log events
 * @param {string} name
 * @param {string} version
 * @param {LogHandler[]} logHandlers
 * @returns {() => OnLog}
 */
function onLogMaker(name, version, logHandlers) {
    return () => new OnLog(name, version, logHandlers);
}
exports.onLogMaker = onLogMaker;
/**
 * Default console logging LogHandler
 * @param {AtomistLog} log
 * @param {HandlerContext} ctx
 * @returns {Promise<void>}
 * @constructor
 */
const ConsoleLogHandler = (log, ctx) => __awaiter(this, void 0, void 0, function* () {
    const date = new Date(log.timestamp);
    logger_1.logger.log(log.level, `Incoming log message '${date} [${log.correlation_context.correlation_id}] ${log.message}'`);
});
//# sourceMappingURL=OnLog.js.map