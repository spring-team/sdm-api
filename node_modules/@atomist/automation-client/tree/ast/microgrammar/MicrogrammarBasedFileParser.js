"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PatternMatch_1 = require("@atomist/microgrammar/PatternMatch");
const enrichment_1 = require("@atomist/tree-path/manipulation/enrichment");
/**
 * Allow path expressions against results from a single microgrammar
 */
class MicrogrammarBasedFileParser {
    constructor(rootName, matchName, grammar) {
        this.rootName = rootName;
        this.matchName = matchName;
        this.grammar = grammar;
    }
    toAst(f) {
        return f.getContent()
            .then(content => {
            const matches = this.grammar.findMatches(content);
            const root = {
                $name: this.rootName,
                $children: matches.map(m => new MicrogrammarBackedTreeNode(this.matchName, m, undefined)),
            };
            enrichment_1.defineDynamicProperties(root);
            enrichment_1.fillInEmptyNonTerminalValues(root, content);
            return root;
        });
    }
}
exports.MicrogrammarBasedFileParser = MicrogrammarBasedFileParser;
/**
 * TreeNode implementation backed by a microgrammar match
 */
class MicrogrammarBackedTreeNode {
    constructor($name, m, $parent) {
        this.$name = $name;
        this.$parent = $parent;
        this.$offset = m.$offset;
        if (PatternMatch_1.isTreePatternMatch(m)) {
            const subs = m.submatches();
            this.$children = Object.getOwnPropertyNames(subs)
                .map(prop => {
                const sub = subs[prop];
                // console.log("Exposing child %s.%s as [%s]", $name, prop, stringify(sub));
                return new MicrogrammarBackedTreeNode(prop, sub, this);
            });
        }
        else {
            // console.log("Exposing terminal %s as [%s]: value=[%s]", $name, stringify(m), m.$matched);
            this.$value = String(m.$value);
        }
    }
}
//# sourceMappingURL=MicrogrammarBasedFileParser.js.map