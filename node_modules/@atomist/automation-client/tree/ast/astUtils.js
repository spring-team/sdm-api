"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const enrichment_1 = require("@atomist/tree-path/manipulation/enrichment");
const expressionEngine_1 = require("@atomist/tree-path/path/expressionEngine");
const pathExpression_1 = require("@atomist/tree-path/path/pathExpression");
const utils_1 = require("@atomist/tree-path/path/utils");
const logger_1 = require("../../internal/util/logger");
const projectUtils_1 = require("../../project/util/projectUtils");
const FileHits_1 = require("./FileHits");
const FileParser_1 = require("./FileParser");
const sourceLocationUtils_1 = require("../../project/util/sourceLocationUtils");
/**
 * Separates glob patterns from path expressions in unified expression syntax
 * @type {string}
 */
exports.ExpressionSeparator = "::";
/**
 * Integrate path expressions with project operations to find all matches
 * using a unified string expression format of the form
 * <glob pattern>-><path expression>
 * This can be useful to foster reuse
 * @param p project
 * @param unifiedExpression file glob pattern + path expression to execute
 * @param parserOrRegistry parser for files
 * @return {Promise<TreeNode[]>} hit record for each matching file
 */
function findByExpression(p, parserOrRegistry, unifiedExpression) {
    const split = unifiedExpression.split(exports.ExpressionSeparator);
    if (split.length !== 2) {
        throw new Error(`Invalid unified expression syntax [${unifiedExpression}]: ` +
            `Format is <glob pattern>${exports.ExpressionSeparator}<path expr>`);
    }
    const globPattern = split[0];
    const pathExpression = _.drop(split, 1).join("");
    logger_1.logger.debug("Glob is [%s], path expression [%s] from [%s]", globPattern, pathExpression, unifiedExpression);
    return findMatches(p, parserOrRegistry, globPattern, pathExpression);
}
exports.findByExpression = findByExpression;
/**
 * Integrate path expressions with project operations to find all matches
 * @param p project
 * @param globPattern file glob pattern
 * @param parserOrRegistry parser for files
 * @param pathExpression path expression string or parsed
 * @param functionRegistry registry to look for path expression functions in
 * @return {Promise<MatchResult[]>} hit records for each matching file
 */
function findMatches(p, parserOrRegistry, globPattern, pathExpression, functionRegistry) {
    return findFileMatches(p, parserOrRegistry, globPattern, pathExpression, functionRegistry)
        .then(fileHits => _.flatten(fileHits.map(f => f.matches)));
}
exports.findMatches = findMatches;
function findFileMatches(p, parserOrRegistry, globPattern, pathExpression, functionRegistry) {
    const parsed = utils_1.toPathExpression(pathExpression);
    const parser = findParser(parsed, parserOrRegistry);
    if (!parser) {
        throw new Error(`Cannot find parser for path expression [${pathExpression}]: Using ${parserOrRegistry}`);
    }
    return projectUtils_1.saveFromFilesAsync(p, globPattern, file => {
        return parser.toAst(file)
            .then(topLevelProduction => {
            logger_1.logger.debug("Successfully parsed file '%s' to AST with root node named '%s'. Will execute '%s'", file.path, topLevelProduction.$name, pathExpression_1.stringify(parsed));
            enrichment_1.defineDynamicProperties(topLevelProduction);
            const fileNode = {
                path: file.path,
                name: file.name,
                $name: file.name,
                $children: [topLevelProduction],
            };
            const r = expressionEngine_1.evaluateExpression(fileNode, parsed, functionRegistry);
            if (pathExpression_1.isSuccessResult(r)) {
                logger_1.logger.debug("%d matches in file '%s'", r.length, file.path);
                return fillInSourceLocations(file, r)
                    .then(locatedNodes => new FileHits_1.FileHit(p, file, fileNode, locatedNodes));
            }
            else {
                logger_1.logger.debug("No matches in file '%s'", file.path);
                return undefined;
            }
        })
            .catch(err => {
            logger_1.logger.info("Failed to parse file '%s': %s", file.path, err);
            return undefined;
        });
    });
}
exports.findFileMatches = findFileMatches;
/**
 * Use file content to fill in LocatedTreeNode.sourceLocation
 * @param {File} f
 * @param {TreeNode[]} nodes
 * @return {Promise<LocatedTreeNode[]>}
 */
function fillInSourceLocations(f, nodes) {
    if (nodes.length === 0) {
        // Optimization.
        // In this case, let's not read the file content and leave source locations undefined
        return Promise.resolve(nodes);
    }
    return f.getContent()
        .then(content => {
        nodes.forEach(n => {
            n.sourceLocation = sourceLocationUtils_1.toSourceLocation(f, content, n.$offset);
        });
        return nodes;
    });
}
/**
 * Convenient method to find all values of matching nodes--
 * typically, terminals such as identifiers
 * @param p project
 * @param globPattern file glob pattern
 * @param parserOrRegistry parser for files
 * @param pathExpression path expression string or parsed
 * @param functionRegistry registry to look for path expression functions in
 * @return {Promise<TreeNode[]>} hit record for each matching file
 */
function findValues(p, parserOrRegistry, globPattern, pathExpression, functionRegistry) {
    return findFileMatches(p, parserOrRegistry, globPattern, pathExpression, functionRegistry)
        .then(fileHits => _.flatten(fileHits.map(f => f.matches))
        .map(m => m.$value));
}
exports.findValues = findValues;
/**
 * Integrate path expressions with project operations to find all matches
 * of a path expression and zap them. Use with care!
 * @param p project
 * @param globPattern file glob pattern
 * @param parserOrRegistry parser for files
 * @param pathExpression path expression string or parsed
 * @param opts options for handling whitespace
 * @return {Promise<TreeNode[]>} hit record for each matching file
 */
function zapAllMatches(p, parserOrRegistry, globPattern, pathExpression, opts = {}) {
    return findFileMatches(p, parserOrRegistry, globPattern, pathExpression)
        .then(fileHits => {
        fileHits.forEach(fh => {
            const sorted = fh.matches.sort((m1, m2) => m1.$offset - m2.$offset);
            sorted.forEach(m => {
                m.zap(opts);
            });
        });
        return p.flush();
    });
}
exports.zapAllMatches = zapAllMatches;
function findParser(pathExpression, fp) {
    if (FileParser_1.isFileParser(fp)) {
        if (!!fp.validate) {
            fp.validate(pathExpression);
        }
        return fp;
    }
    else {
        return fp.parserFor(pathExpression);
    }
}
exports.findParser = findParser;
//# sourceMappingURL=astUtils.js.map