import { PathExpression } from "@atomist/tree-path/path/pathExpression";
import { TreeNode } from "@atomist/tree-path/TreeNode";
import { File } from "../../project/File";
import { ProjectAsync } from "../../project/Project";
import { LocatedTreeNode } from "../LocatedTreeNode";
/**
 * Options for handling production replacements
 */
export interface NodeReplacementOptions {
    replaceAfter?: {
        after: RegExp;
        replacement: string;
    };
}
/**
 * Replacement option to zap trailing whitespace
 * @type {{replaceAfter: {after: RegExp; replacement: string}}}
 */
export declare const ZapTrailingWhitespace: NodeReplacementOptions;
/**
 * Extension of TreeNode that allows convenient addition before
 * or after a node, without updating the node's value.
 */
export interface MatchResult extends LocatedTreeNode {
    append(content: string): any;
    prepend(content: string): any;
    /**
     * Delete the match. Same as setting $value to the empty string,
     * but can zap trailing spaces also
     * @param {NodeReplacementOptions} opts
     */
    zap(opts: NodeReplacementOptions): any;
    replace(newContent: string, opts: NodeReplacementOptions): any;
    evaluateExpression(pex: string | PathExpression): any;
}
/**
 * Represents a file and the hits against it
 */
export declare class FileHit {
    private project;
    file: File;
    fileNode: TreeNode;
    readonly nodes: LocatedTreeNode[];
    readonly matches: MatchResult[];
    /**
     * Represents the hits within a file within a project
     * @param project
     * @param {File} file file within the project
     * @param {TreeNode} fileNode node structure including AST, so
     * that if we want to dig into it or run further path expressions
     * we don't need to reparse the file.
     * @param {TreeNode[]} nodes
     */
    constructor(project: ProjectAsync, file: File, fileNode: TreeNode, nodes: LocatedTreeNode[]);
}
