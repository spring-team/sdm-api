import { PathExpression } from "@atomist/tree-path/path/pathExpression";
import { ProjectAsync } from "../../project/Project";
import { FileHit, MatchResult, NodeReplacementOptions } from "./FileHits";
import { FileParser } from "./FileParser";
import { FileParserRegistry } from "./FileParserRegistry";
/**
 * Separates glob patterns from path expressions in unified expression syntax
 * @type {string}
 */
export declare const ExpressionSeparator = "::";
/**
 * Integrate path expressions with project operations to find all matches
 * using a unified string expression format of the form
 * <glob pattern>-><path expression>
 * This can be useful to foster reuse
 * @param p project
 * @param unifiedExpression file glob pattern + path expression to execute
 * @param parserOrRegistry parser for files
 * @return {Promise<TreeNode[]>} hit record for each matching file
 */
export declare function findByExpression(p: ProjectAsync, parserOrRegistry: FileParser | FileParserRegistry, unifiedExpression: string): Promise<MatchResult[]>;
/**
 * Integrate path expressions with project operations to find all matches
 * @param p project
 * @param globPattern file glob pattern
 * @param parserOrRegistry parser for files
 * @param pathExpression path expression string or parsed
 * @param functionRegistry registry to look for path expression functions in
 * @return {Promise<MatchResult[]>} hit records for each matching file
 */
export declare function findMatches(p: ProjectAsync, parserOrRegistry: FileParser | FileParserRegistry, globPattern: string, pathExpression: string | PathExpression, functionRegistry?: object): Promise<MatchResult[]>;
export declare function findFileMatches(p: ProjectAsync, parserOrRegistry: FileParser | FileParserRegistry, globPattern: string, pathExpression: string | PathExpression, functionRegistry?: object): Promise<FileHit[]>;
/**
 * Convenient method to find all values of matching nodes--
 * typically, terminals such as identifiers
 * @param p project
 * @param globPattern file glob pattern
 * @param parserOrRegistry parser for files
 * @param pathExpression path expression string or parsed
 * @param functionRegistry registry to look for path expression functions in
 * @return {Promise<TreeNode[]>} hit record for each matching file
 */
export declare function findValues(p: ProjectAsync, parserOrRegistry: FileParser | FileParserRegistry, globPattern: string, pathExpression: string | PathExpression, functionRegistry?: object): Promise<string[]>;
/**
 * Integrate path expressions with project operations to find all matches
 * of a path expression and zap them. Use with care!
 * @param p project
 * @param globPattern file glob pattern
 * @param parserOrRegistry parser for files
 * @param pathExpression path expression string or parsed
 * @param opts options for handling whitespace
 * @return {Promise<TreeNode[]>} hit record for each matching file
 */
export declare function zapAllMatches<P extends ProjectAsync = ProjectAsync>(p: P, parserOrRegistry: FileParser | FileParserRegistry, globPattern: string, pathExpression: string | PathExpression, opts?: NodeReplacementOptions): Promise<P>;
export declare function findParser(pathExpression: PathExpression, fp: FileParser | FileParserRegistry): FileParser;
