import { TreeNode } from "@atomist/tree-path/TreeNode";
import { FileParser } from "../FileParser";
import { PathExpression } from "@atomist/tree-path/path/pathExpression";
import * as ts from "typescript";
import { File } from "../../../project/File";
/**
 * Allow path expressions against ASTs from the TypeScript parser.
 * For reference material on the grammar, and which productions are legal
 * names in path expressions, see the grammar at
 * https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#A.
 * See also the ES6 grammar of which TypeScript is a superset:
 * http://www.ecma-international.org/ecma-262/6.0/#sec-grammar-summary.
 * and the SyntaxKind type defined by
 * the TypeScript compiler. Invalid production names will be rejected
 * with a runtime error.
 *
 * Will try to determine TypeScript ScriptKind from the file extension.
 */
export declare class TypeScriptFileParser implements FileParser {
    scriptTarget: ts.ScriptTarget;
    rootName: string;
    constructor(scriptTarget: ts.ScriptTarget);
    toAst(f: File): Promise<TreeNode>;
    /**
     * Check that this path expression uses only valid TypeScript constructs
     * @param {PathExpression} pex
     */
    validate(pex: PathExpression): void;
}
/**
 * Parser for TypeScript and JavaScript
 * @type {TypeScriptFileParser}
 */
export declare const TypeScriptES6FileParser: TypeScriptFileParser;
