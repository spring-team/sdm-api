"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const appRoot = require("app-root-path");
const logger_1 = require("./internal/util/logger");
const string_1 = require("./internal/util/string");
class HandlerRegistry {
    constructor() {
        this.commands = [];
        this.events = [];
        this.scanForCommands = false;
        this.scanForEvents = false;
    }
    registerCommand(command) {
        if (this.scanForCommands) {
            logger_1.logger.debug(`Registered command '${command.name}'`);
            if (typeof command === "function") {
                this.commands.push(command);
            }
            else {
                this.commands.push(() => Object.create(command));
            }
        }
    }
    registerEvent(event) {
        if (this.scanForEvents) {
            logger_1.logger.debug(`Registered event '${event.name}'`);
            if (typeof event === "function") {
                this.events.push(event);
            }
            else {
                this.events.push(() => Object.create(event));
            }
        }
    }
    start(commands, events) {
        this.commands = [];
        this.scanForCommands = commands;
        this.events = [];
        this.scanForEvents = events;
    }
}
const registry = new HandlerRegistry();
function registerCommand(command) {
    registry.registerCommand(command);
}
exports.registerCommand = registerCommand;
function registerEvent(event) {
    registry.registerEvent(event);
}
exports.registerEvent = registerEvent;
/*
 * Scan the node module/project for command handlers.
 * Optional glob patterns can be specified to narrow the search.
 */
function scanCommands(patterns = ["**/commands/**/*.js"]) {
    registry.start(true, false);
    // tslint:disable-next-line:variable-name
    const _patterns = string_1.toStringArray(patterns);
    logger_1.logger.info(`Scanning for commands using file patterns: ${_patterns.join(", ")}`);
    scan(_patterns);
    logger_1.logger.debug(`Completed scanning for commands`);
    return registry.commands;
}
exports.scanCommands = scanCommands;
/*
 * Scan the node module/project for event handlers.
 * Optional glob patterns can be specified to narrow the search.
 */
function scanEvents(patterns = ["**/events/**/*.js"]) {
    registry.start(false, true);
    // tslint:disable-next-line:variable-name
    const _patterns = string_1.toStringArray(patterns);
    logger_1.logger.info(`Scanning for events using file patterns: ${_patterns.join(", ")}`);
    scan(_patterns);
    logger_1.logger.debug(`Completed scanning for events`);
    return registry.events;
}
exports.scanEvents = scanEvents;
/*
 * Enable scanning on the given Configuration instance.
 */
function enableDefaultScanning(configuration) {
    if (!configuration.commands) {
        configuration.commands = scanCommands();
    }
    if (!configuration.events) {
        configuration.events = scanEvents();
    }
    return configuration;
}
exports.enableDefaultScanning = enableDefaultScanning;
function scan(patterns) {
    const glob = require("glob");
    patterns.forEach(pattern => {
        const ignore = ["**/node_modules/**", "**/.git/**", "**/*Test.js", "**/*Tests.js"];
        const files = glob.sync(pattern, { ignore });
        files.forEach(f => safeRequire(f));
    });
}
function safeRequire(file) {
    try {
        logger_1.logger.debug(`Scanning file '${file}'`);
        require(`${appRoot.path}/${file}`);
    }
    catch (err) {
        logger_1.logger.warn(`Can't require '${file}': ${err.message}`);
    }
}
//# sourceMappingURL=scan.js.map