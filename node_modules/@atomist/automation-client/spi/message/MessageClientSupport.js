"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const string_1 = require("../../internal/util/string");
const MessageClient_1 = require("./MessageClient");
class MessageClientSupport {
    respond(msg, options) {
        return this.doSend(msg, [], options);
    }
    send(msg, destinations, options) {
        if (!Array.isArray(destinations)) {
            destinations = [destinations];
        }
        return this.doSend(msg, destinations, options);
    }
}
exports.MessageClientSupport = MessageClientSupport;
exports.Query = `
query ChatTeam {
  ChatTeam {
    id
  }
}`;
class DefaultSlackMessageClient {
    constructor(delegate, graphClient) {
        this.delegate = delegate;
        this.graphClient = graphClient;
    }
    respond(msg, options) {
        return this.delegate.respond(msg, options);
    }
    send(msg, destinations, options) {
        return this.delegate.send(msg, destinations, options);
    }
    addressUsers(msg, users, options) {
        if (!users || Array.isArray(users) && users.length === 0) {
            throw new Error("Please pass at least one user");
        }
        return this.lookupChatTeam()
            .then(chatTeamId => this.delegate.send(msg, MessageClient_1.addressSlackUsers(chatTeamId, ...string_1.toStringArray(users)), options));
    }
    addressChannels(msg, channels, options) {
        if (!channels || Array.isArray(channels) && channels.length === 0) {
            throw new Error("Please pass at least one channel");
        }
        return this.lookupChatTeam()
            .then(chatTeamId => this.delegate.send(msg, MessageClient_1.addressSlackChannels(chatTeamId, ...string_1.toStringArray(channels)), options));
    }
    lookupChatTeam() {
        if (this.graphClient) {
            return this.graphClient.executeQuery(exports.Query, {})
                .then(result => {
                if (result.ChatTeam.length > 1) {
                    return Promise.reject("More then 1 ChatTeam found. Please use fully qualified " +
                        "message addressing available on MessageClient");
                }
                else {
                    return result.ChatTeam[0].id;
                }
            });
        }
        else {
            return Promise.reject("No GraphClient to lookup ChatTeam. Please use fully qualified message " +
                "addressing available on MessageClient");
        }
    }
}
exports.DefaultSlackMessageClient = DefaultSlackMessageClient;
//# sourceMappingURL=MessageClientSupport.js.map