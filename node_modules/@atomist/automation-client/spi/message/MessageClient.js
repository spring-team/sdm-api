"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const metadataReading_1 = require("../../internal/metadata/metadataReading");
/**
 * Message Destination for Slack.
 */
class SlackDestination {
    constructor(team) {
        this.team = team;
        this.userAgent = SlackDestination.SLACK_USER_AGENT;
        this.users = [];
        this.channels = [];
    }
    /**
     * Address certain users by their user name.
     * @param {string} user
     * @returns {SlackDestination}
     */
    addressUser(user) {
        this.users.push(user);
        return this;
    }
    /**
     * Address certains channels by their channel name.
     * @param {string} channel
     * @returns {SlackDestination}
     */
    addressChannel(channel) {
        this.channels.push(channel);
        return this;
    }
}
SlackDestination.SLACK_USER_AGENT = "slack";
exports.SlackDestination = SlackDestination;
/**
 * Shortcut for creating a SlackDestination which addresses the given users.
 * @param {string} team
 * @param {string} users
 * @returns {SlackDestination}
 */
function addressSlackUsers(team, ...users) {
    const sd = new SlackDestination(team);
    users.forEach(u => sd.addressUser(u));
    return sd;
}
exports.addressSlackUsers = addressSlackUsers;
/**
 * Shortcut for creating a SlackDestination which addresses the given channels.
 * @param {string} team
 * @param {string} channels
 * @returns {SlackDestination}
 */
function addressSlackChannels(team, ...channels) {
    const sd = new SlackDestination(team);
    channels.forEach(c => sd.addressChannel(c));
    return sd;
}
exports.addressSlackChannels = addressSlackChannels;
/**
 * Message Destination for Custom Event types.
 */
class CustomEventDestination {
    constructor(rootType) {
        this.rootType = rootType;
        this.userAgent = CustomEventDestination.INGESTER_USER_AGENT;
    }
}
CustomEventDestination.INGESTER_USER_AGENT = "ingester";
exports.CustomEventDestination = CustomEventDestination;
function addressEvent(rootType) {
    return new CustomEventDestination(rootType);
}
exports.addressEvent = addressEvent;
class MessageMimeTypes {
}
MessageMimeTypes.SLACK_JSON = "application/x-atomist-slack+json";
MessageMimeTypes.SLACK_FILE_JSON = "application/x-atomist-slack-file+json";
MessageMimeTypes.PLAIN_TEXT = "text/plain";
MessageMimeTypes.APPLICATION_JSON = "application/json";
exports.MessageMimeTypes = MessageMimeTypes;
function buttonForCommand(buttonSpec, command, parameters = {}) {
    const cmd = commandName(command);
    parameters = mergeParameters(command, parameters);
    const id = cmd.toLocaleLowerCase();
    const action = rugButtonFrom(buttonSpec, { id });
    action.command = {
        id,
        name: cmd,
        parameters,
    };
    return action;
}
exports.buttonForCommand = buttonForCommand;
function menuForCommand(selectSpec, command, parameterName, parameters = {}) {
    const cmd = commandName(command);
    parameters = mergeParameters(command, parameters);
    const id = cmd.toLocaleLowerCase();
    const action = rugMenuFrom(selectSpec, { id, parameterName });
    action.command = {
        id,
        name: cmd,
        parameters,
        parameterName,
    };
    return action;
}
exports.menuForCommand = menuForCommand;
function isSlackMessage(object) {
    return (object.text || object.attachments) && !object.content;
}
exports.isSlackMessage = isSlackMessage;
function isFileMessage(object) {
    return !object.length && object.content;
}
exports.isFileMessage = isFileMessage;
function commandName(command) {
    try {
        if (typeof command === "string") {
            return command;
        }
        else if (typeof command === "function") {
            return command.prototype.constructor.name;
        }
        else {
            return metadataReading_1.metadataFromInstance(command).name;
        }
    }
    catch (e) {
        throw new Error("Unable to determine the name of this command. " +
            "Please pass the name as a string or an instance of the command");
    }
}
exports.commandName = commandName;
function mergeParameters(command, parameters) {
    // Reuse parameters defined on the instance
    if (typeof command !== "string" && typeof command !== "function") {
        parameters = Object.assign({}, command, parameters);
    }
    return parameters;
}
exports.mergeParameters = mergeParameters;
function rugButtonFrom(action, command) {
    if (!command.id) {
        throw new Error(`Please provide a valid non-empty command id`);
    }
    const button = {
        text: action.text,
        type: "button",
        name: `automation-command::${command.id}`,
    };
    _.forOwn(action, (v, k) => {
        button[k] = v;
    });
    return button;
}
function rugMenuFrom(action, command) {
    if (!command.id) {
        throw new Error("SelectableIdentifiableInstruction must have id set");
    }
    if (!command.parameterName) {
        throw new Error("SelectableIdentifiableInstruction must have parameterName set");
    }
    const select = {
        text: action.text,
        type: "select",
        name: `automation-command::${command.id}`,
    };
    if (typeof action.options === "string") {
        select.data_source = action.options;
    }
    else if (action.options.length > 0) {
        const first = action.options[0];
        if (first.value) {
            // then it's normal options
            select.options = action.options;
        }
        else {
            // then it's option groups
            select.option_groups = action.options;
        }
    }
    _.forOwn(action, (v, k) => {
        if (k !== "options") {
            select[k] = v;
        }
    });
    return select;
}
//# sourceMappingURL=MessageClient.js.map