import { Action, SlackMessage } from "@atomist/slack-messages/SlackMessages";
/**
 * Implemented by classes that can send bot messages, whether to
 * channels or individuals, including actions and updates.
 */
export interface MessageClient {
    /**
     * Send a response back to where this command request originated.
     * @param msg
     * @param {MessageOptions} options
     * @returns {Promise<any>}
     */
    respond(msg: any, options?: MessageOptions): Promise<any>;
    /**
     * Send a message to any given destination.
     * @param msg
     * @param {Destination | Destination[]} destinations
     * @param {MessageOptions} options
     * @returns {Promise<any>}
     */
    send(msg: any, destinations: Destination | Destination[], options?: MessageOptions): Promise<any>;
}
/**
 * MessageClient to send messages to the default Slack team.
 *
 * Note: This implementation is deprecated in favor of MessageClient.
 */
export interface SlackMessageClient {
    addressUsers(msg: string | SlackMessage, users: string | string[], options?: MessageOptions): Promise<any>;
    addressChannels(msg: string | SlackMessage, channels: string | string[], options?: MessageOptions): Promise<any>;
}
/**
 * Basic message destination.
 */
export interface Destination {
    userAgent: string;
}
/**
 * Message Destination for Slack.
 */
export declare class SlackDestination implements Destination {
    team: string;
    static SLACK_USER_AGENT: string;
    userAgent: string;
    users: string[];
    channels: string[];
    constructor(team: string);
    /**
     * Address certain users by their user name.
     * @param {string} user
     * @returns {SlackDestination}
     */
    addressUser(user: string): SlackDestination;
    /**
     * Address certains channels by their channel name.
     * @param {string} channel
     * @returns {SlackDestination}
     */
    addressChannel(channel: string): SlackDestination;
}
/**
 * Shortcut for creating a SlackDestination which addresses the given users.
 * @param {string} team
 * @param {string} users
 * @returns {SlackDestination}
 */
export declare function addressSlackUsers(team: string, ...users: string[]): SlackDestination;
/**
 * Shortcut for creating a SlackDestination which addresses the given channels.
 * @param {string} team
 * @param {string} channels
 * @returns {SlackDestination}
 */
export declare function addressSlackChannels(team: string, ...channels: string[]): SlackDestination;
/**
 * Message Destination for Custom Event types.
 */
export declare class CustomEventDestination implements Destination {
    rootType: string;
    static INGESTER_USER_AGENT: string;
    userAgent: string;
    constructor(rootType: string);
}
export declare function addressEvent(rootType: string): CustomEventDestination;
/**
 * Message to create a Snippet in Slack
 */
export interface SlackFileMessage {
    content: string;
    title?: string;
    fileName?: string;
    fileType?: string;
    comment?: string;
}
export interface MessageOptions {
    /**
     * Unique message id per channel and team. This is required
     * if you wish to re-write a message at a later time.
     */
    id?: string;
    /**
     * Time to live for a posted message. If ts + ttl of the
     * existing message with ts is < as a new incoming message
     * with the same id, the message will be re-written.
     */
    ttl?: number;
    /**
     * Timestamp of the message. The timestamp needs to be
     * sortable lexicographically. Should be in milliseconds and
     * defaults to Date.now().
     *
     * This is only applicable if id is set too.
     */
    ts?: number;
    /**
     * If update_only is given, this message will only be posted
     * if a previous message with the same id exists.
     */
    post?: "update_only" | "always";
}
export declare class MessageMimeTypes {
    static SLACK_JSON: string;
    static SLACK_FILE_JSON: string;
    static PLAIN_TEXT: string;
    static APPLICATION_JSON: string;
}
export interface CommandReferencingAction extends Action {
    command: CommandReference;
}
export interface CommandReference {
    /**
     * The id of the action as referenced in the markup.
     */
    id: string;
    /**
     * The name of the command the button or menu should invoke
     * when selected.
     */
    name: string;
    /**
     *  List of parameters to be passed to the command.
     */
    parameters?: {};
    /**
     * Name of the parameter that should be used to pass the values
     * of the menu drop-down.
     */
    parameterName?: string;
}
export declare function buttonForCommand(buttonSpec: ButtonSpecification, command: any, parameters?: {
    [name: string]: string | number | boolean;
}): Action;
export declare function menuForCommand(selectSpec: MenuSpecification, command: any, parameterName: string, parameters?: {
    [name: string]: string | number | boolean;
}): Action;
export declare function isSlackMessage(object: any): object is SlackMessage;
export declare function isFileMessage(object: any): object is SlackFileMessage;
export declare function commandName(command: any): string;
export declare function mergeParameters(command: any, parameters: any): any;
export interface ActionConfirmation {
    title?: string;
    text: string;
    ok_text?: string;
    dismiss_text?: string;
}
export interface ButtonSpecification {
    text: string;
    style?: string;
    confirm?: ActionConfirmation;
    role?: string;
}
export interface SelectOption {
    text: string;
    value: string;
}
export interface OptionGroup {
    text: string;
    options: SelectOption[];
}
export declare type DataSource = "static" | "users" | "channels" | "conversations" | "external";
export interface MenuSpecification {
    text: string;
    options: SelectOption[] | DataSource | OptionGroup[];
    role?: string;
}
