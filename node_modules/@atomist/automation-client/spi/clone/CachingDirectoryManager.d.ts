import { DirectoryManager } from "./DirectoryManager";
/**
 * Designed to accommodate occasional writes to the same repositories,
 * this keeps one clone available for each repository. Every time that repository is requested,
 * if that clone is available, we return it. (The caller gets to fetch, clean, etc. The directory could be dirty.)
 * If that clone is locked by some other automation invocation, this
 * DirectoryManager returns a temporary directory, and you get to clone into that.
 *
 * If the returned CloneDirectoryInfo has type: "empty-directory"
 * then the caller should clone into it (not from it, you're not in the parent directory).
 * If it has type: "existing-directory" then fetch, clean, checkout etc. given it's already cloned.
 *
 * @type {{directoryFor:
 * ((owner: string, repo: string, branch: string, opts: CloneOptions) => Promise<CloneDirectoryInfo>)}}
 */
export declare const CachingDirectoryManager: DirectoryManager;
export declare const ReuseKey = "directory_cache.reuse";
export declare const FallbackKey = "directory_cache.fallback";
interface LockAcquired {
    success: true;
    release: () => Promise<void>;
}
interface NoLockForYou {
    success: false;
    error: Error;
}
export { pleaseLock, LockResult, LockAcquired, NoLockForYou };
declare type LockResult = LockAcquired | NoLockForYou;
declare function pleaseLock(lockPath: string): Promise<LockResult>;
