import { HandlerContext } from "../../HandlerContext";
import { Project } from "../../project/Project";
import { EditResult, ProjectEditor } from "./projectEditor";
/**
 * Used to determine EditMode on a per project basis,
 * for example if we want to use a different branch name on different repos
 */
export declare type EditModeFactory = (p: Project) => EditMode;
export declare function toEditModeFactory(em: EditMode | EditModeFactory): EditModeFactory;
/**
 * Root interface for information on how to apply an edit:
 * E.g via a PR or commit to a branch (including master)
 */
export interface EditMode {
    message: string;
    /**
     * Optional method to perform any additional actions on the project after
     * applying the edit to persistent store--for example, setting a GitHub status
     * @param {Project} p
     * @return {Promise<any>}
     */
    afterPersist?(p: Project): Promise<any>;
}
export declare function isEditMode(em: any): em is EditMode;
/**
 * Represents a commit to a project on a branch
 */
export interface BranchCommit extends EditMode {
    branch: string;
}
/**
 * Return a commit to master branch with the given message. Use with care!
 */
export declare function commitToMaster(message: string): BranchCommit;
export declare function isBranchCommit(em: EditMode): em is BranchCommit;
/**
 * Captures extra steps that must go into raising a PR
 */
export declare class PullRequest implements BranchCommit {
    branch: string;
    title: string;
    body: string;
    message: string;
    constructor(branch: string, title: string, body?: string, message?: string);
}
export declare function isPullRequest(em: EditMode): em is PullRequest;
/**
 * Use for edit modes that require custom persistence
 */
export interface CustomExecutionEditMode extends EditMode {
    edit<P>(p: Project, action: ProjectEditor<P>, context: HandlerContext, parameters: P): Promise<EditResult>;
}
export declare function isCustomExecutionEditMode(ei: EditMode): ei is CustomExecutionEditMode;
