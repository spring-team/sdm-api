"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("../../internal/util/logger");
const projectEditor_1 = require("./projectEditor");
/**
 * Chain the editors, in the given order
 * @param {ProjectEditor} projectEditors
 * @return {ProjectEditor}
 */
function chainEditors(...projectEditors) {
    const asProjectEditors = projectEditors.map(projectEditor_1.toEditor);
    return (p, ctx, params) => __awaiter(this, void 0, void 0, function* () {
        try {
            let cumulativeResult = {
                target: p,
                success: true,
                edited: false,
            };
            for (const pe of asProjectEditors) {
                const lastResult = yield pe(p, ctx, params);
                cumulativeResult = combineEditResults(lastResult, cumulativeResult);
            }
            return cumulativeResult;
        }
        catch (error) {
            logger_1.logger.warn("Editor failure in editorChain: %s", error);
            return { target: p, edited: false, success: false, error };
        }
    });
}
exports.chainEditors = chainEditors;
function combineEditResults(r1, r2) {
    return Object.assign({}, r1, r2, { edited: (r1.edited || r2.edited) ? true :
            (r1.edited === false && r2.edited === false) ? false : undefined, success: r1.success && r2.success });
}
exports.combineEditResults = combineEditResults;
/**
 * Useful starting point for editor chaining
 * @param {Project} p
 * @constructor
 */
exports.NoOpEditor = p => Promise.resolve(projectEditor_1.successfulEdit(p, false));
//# sourceMappingURL=projectEditorOps.js.map