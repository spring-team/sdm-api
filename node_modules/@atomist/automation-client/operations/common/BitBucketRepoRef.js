"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ActionResult_1 = require("../../action/ActionResult");
const logger_1 = require("../../internal/util/logger");
const AbstractRemoteRepoRef_1 = require("./AbstractRemoteRepoRef");
const axios_1 = require("axios");
const base64_1 = require("../../internal/util/base64");
const BasicAuthCredentials_1 = require("./BasicAuthCredentials");
const RepoId_1 = require("./RepoId");
exports.BitBucketDotComBase = "https://bitbucket.org/api/2.0";
class BitBucketRepoRef extends AbstractRemoteRepoRef_1.AbstractRepoRef {
    constructor(owner, repo, sha = "master", apiBase = exports.BitBucketDotComBase, path) {
        super(RepoId_1.ProviderType.bitbucket_cloud, "bitbucket.org", owner, repo, sha, path);
        this.apiBase = apiBase;
    }
    createRemote(creds, description, visibility) {
        const url = `${this.apiBase}/repositories/${this.owner}/${this.repo}`;
        return axios_1.default.post(url, {
            scm: "git",
            is_private: visibility === "private",
        }, headers(creds))
            .then(axiosResponse => {
            return {
                target: this,
                success: true,
                axiosResponse,
            };
        })
            .catch(error => {
            logger_1.logger.error("Error attempting to create repository %j: %s", this, error);
            return Promise.resolve({
                target: this,
                success: false,
                error,
            });
        });
    }
    deleteRemote(creds) {
        const url = `${this.apiBase}/repositories/${this.owner}/${this.repo}`;
        logger_1.logger.debug(`Making request to '${url}' to delete repo`);
        return axios_1.default.delete(url, headers(creds))
            .then(axiosResponse => {
            return {
                target: this,
                success: true,
                axiosResponse,
            };
        })
            .catch(err => {
            logger_1.logger.error("Error attempting to delete repository: " + err);
            return Promise.reject(err);
        });
    }
    setUserConfig(credentials, project) {
        return Promise.resolve(ActionResult_1.successOn(this));
    }
    raisePullRequest(credentials, title, body, head, base) {
        const url = `${this.apiBase}/repositories/${this.owner}/${this.repo}/pullrequests`;
        logger_1.logger.debug(`Making request to '${url}' to raise PR`);
        return axios_1.default.post(url, {
            title,
            description: body,
            source: {
                branch: {
                    name: head,
                },
            },
            destination: {
                branch: {
                    name: base,
                },
            },
        }, headers(credentials))
            .then(axiosResponse => {
            return {
                target: this,
                success: true,
                axiosResponse,
            };
        })
            .catch(err => {
            logger_1.logger.error("Error attempting to raise PR: " + err);
            return Promise.reject(err);
        });
    }
}
exports.BitBucketRepoRef = BitBucketRepoRef;
function headers(creds) {
    if (!BasicAuthCredentials_1.isBasicAuthCredentials(creds)) {
        throw new Error("Only Basic auth supported: Had " + JSON.stringify(creds));
    }
    const upwd = `${creds.username}:${creds.password}`;
    const encoded = base64_1.encode(upwd);
    return {
        headers: {
            Authorization: `Basic ${encoded}`,
        },
    };
}
//# sourceMappingURL=BitBucketRepoRef.js.map