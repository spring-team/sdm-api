"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ActionResult_1 = require("../../action/ActionResult");
const gitHub_1 = require("../../util/gitHub");
const ProjectOperationCredentials_1 = require("./ProjectOperationCredentials");
const RepoId_1 = require("./RepoId");
const axios_1 = require("axios");
const logger_1 = require("../../internal/util/logger");
const AbstractRemoteRepoRef_1 = require("./AbstractRemoteRepoRef");
const gitHubPatterns_1 = require("./params/gitHubPatterns");
exports.GitHubDotComBase = "https://api.github.com";
/**
 * GitHub repo ref
 */
class GitHubRepoRef extends AbstractRemoteRepoRef_1.AbstractRepoRef {
    constructor(owner, repo, sha = "master", rawApiBase = exports.GitHubDotComBase, path) {
        super(rawApiBase === exports.GitHubDotComBase ? RepoId_1.ProviderType.github_com : RepoId_1.ProviderType.ghe, "github.com", owner, repo, sha, path);
        this.kind = "github";
        // Strip trailing / if present on API base
        this.apiBase = rawApiBase.replace(/\/$/, "");
    }
    static from(params) {
        if (params.sha && !params.sha.match(gitHubPatterns_1.GitShaRegExp.pattern)) {
            throw new Error("You provided an invalid SHA: " + params.sha);
        }
        /*
         * Replicate legacy behavior of: if we have only a branch and not a sha, put it in the sha.
         */
        const result = new GitHubRepoRef(params.owner, params.repo, params.sha || params.branch, params.rawApiBase, params.path);
        result.branch = params.branch;
        return result;
    }
    createRemote(creds, description, visibility) {
        if (!ProjectOperationCredentials_1.isTokenCredentials(creds)) {
            throw new Error("Only token auth supported");
        }
        return gitHub_1.createRepo(creds.token, this, description, visibility)
            .then(() => ActionResult_1.successOn(this));
    }
    setUserConfig(credentials, project) {
        const config = headers(credentials);
        return Promise.all([axios_1.default.get(`${this.apiBase}/user`, config),
            axios_1.default.get(`${this.apiBase}/user/emails`, config)])
            .then(results => {
            const name = results[0].data.name || results[0].data.login;
            let email = results[0].data.email;
            if (!email) {
                email = results[1].data.find(e => e.primary === true).email;
            }
            if (name && email) {
                return project.setUserConfig(name, email);
            }
            else {
                return project.setUserConfig("Atomist Bot", "bot@atomist.com");
            }
        })
            .catch(() => project.setUserConfig("Atomist Bot", "bot@atomist.com"));
    }
    raisePullRequest(credentials, title, body, head, base) {
        const url = `${this.apiBase}/repos/${this.owner}/${this.repo}/pulls`;
        const config = headers(credentials);
        logger_1.logger.debug(`Making request to '${url}' to raise PR`);
        return axios_1.default.post(url, {
            title,
            body,
            head,
            base,
        }, config)
            .then(axiosResponse => {
            return {
                target: this,
                success: true,
                axiosResponse,
            };
        })
            .catch(err => {
            logger_1.logger.error("Error attempting to raise PR: " + err);
            return Promise.reject(err);
        });
    }
    deleteRemote(creds) {
        const url = `${this.apiBase}/repos/${this.owner}/${this.repo}`;
        return axios_1.default.delete(url, headers(creds))
            .then(r => ActionResult_1.successOn(this));
    }
}
exports.GitHubRepoRef = GitHubRepoRef;
function isGitHubRepoRef(rr) {
    const maybe = rr;
    return maybe && !!maybe.apiBase && maybe.kind === "github";
}
exports.isGitHubRepoRef = isGitHubRepoRef;
function headers(credentials) {
    if (!ProjectOperationCredentials_1.isTokenCredentials(credentials)) {
        throw new Error("Only token auth supported");
    }
    return {
        headers: {
            Authorization: `token ${credentials.token}`,
        },
    };
}
//# sourceMappingURL=GitHubRepoRef.js.map