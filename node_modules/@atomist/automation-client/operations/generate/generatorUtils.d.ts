import { ActionResult } from "../../action/ActionResult";
import { HandlerContext } from "../../HandlerContext";
import { Project } from "../../project/Project";
import { DirectoryManager } from "../../spi/clone/DirectoryManager";
import { ProjectAction } from "../common/projectAction";
import { ProjectOperationCredentials } from "../common/ProjectOperationCredentials";
import { RepoId } from "../common/RepoId";
import { AnyProjectEditor } from "../edit/projectEditor";
/**
 * Function that knows how to persist a project using the given credentials.
 * Can take parameters and return a subclass of action result.
 */
export declare type ProjectPersister<P extends Project = Project, R extends ActionResult<P> = ActionResult<P>> = (p: Project, credentials: ProjectOperationCredentials, targetId: RepoId, params?: object) => Promise<R>;
/**
 * Generate a new project given the starting point project.
 * Do not change the starting point. May perform additional
 * action after persisting the project.
 * @param {Promise<Project>} startingPoint
 * @param {HandlerContext} ctx
 * @param {ProjectOperationCredentials} credentials
 * @param {ProjectEditor} editor editor that does the actual transformation
 * @param persist persist function to persist the new project:
 * for example, to GitHub
 * @param targetId id of target repo for persistence
 * @param params optional parameters to be passed to persister
 * @param afterAction action to perform after project persistence.
 * @param directoryManager finds a directory for the new project; defaults to tmp
 */
export declare function generate<P extends Project = Project, PARAMS = object>(startingPoint: Promise<Project> | Project, ctx: HandlerContext, credentials: ProjectOperationCredentials, editor: AnyProjectEditor, persist: ProjectPersister<P>, targetId: RepoId, params?: PARAMS, afterAction?: ProjectAction<PARAMS, P>, directoryManager?: DirectoryManager): Promise<ActionResult<P>>;
