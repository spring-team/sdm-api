"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const onCommand_1 = require("../../onCommand");
const CachingDirectoryManager_1 = require("../../spi/clone/CachingDirectoryManager");
const GraphClient_1 = require("../../spi/graph/GraphClient");
const allReposInTeamRepoFinder_1 = require("../common/allReposInTeamRepoFinder");
const defaultRepoLoader_1 = require("../common/defaultRepoLoader");
const GitHubRepoRef_1 = require("../common/GitHubRepoRef");
const generatorUtils_1 = require("./generatorUtils");
const remoteGitProjectPersister_1 = require("./remoteGitProjectPersister");
const addAtomistWebhook_1 = require("./support/addAtomistWebhook");
function defaultDetails(name) {
    return {
        description: name,
        repoFinder: allReposInTeamRepoFinder_1.allReposInTeam(),
        repoLoader: (p) => defaultRepoLoader_1.defaultRepoLoader(p.target.credentials, CachingDirectoryManager_1.CachingDirectoryManager),
        projectPersister: remoteGitProjectPersister_1.RemoteGitProjectPersister,
        redirecter: () => undefined,
    };
}
/**
 * Create a generator function wrapping the given transform
 *
 * DEPRECATED: use the one in @atomist/sdm
 *
 * @param {AnyProjectEditor} editorFactory editor for the transformation
 * @param factory construction function
 * @param {string} name name of the generator
 * @param {string} details object allowing customization beyond reasonable defaults
 * @return {HandleCommand}
 */
function generatorHandler(editorFactory, factory, name, details = {}) {
    const detailsToUse = Object.assign({}, defaultDetails(name), details);
    return onCommand_1.commandHandlerFrom(handleGenerate(editorFactory, detailsToUse), factory, name, detailsToUse.description, detailsToUse.intent, detailsToUse.tags);
}
exports.generatorHandler = generatorHandler;
function handleGenerate(editorFactory, details) {
    return (ctx, parameters) => {
        return handle(ctx, editorFactory, parameters, details);
    };
}
function handle(ctx, editorFactory, params, details) {
    return ctx.messageClient.respond(`Starting project generation for ${params.target.repoRef.owner}/${params.target.repoRef.repo}`)
        .then(() => {
        return generatorUtils_1.generate(startingPoint(params, ctx, details.repoLoader(params), details)
            .then(p => {
            return ctx.messageClient.respond(`Cloned seed project from \`${params.source.repoRef.owner}/${params.source.repoRef.repo}\``)
                .then(() => p);
        }), ctx, params.target.credentials, editorFactory(params, ctx), details.projectPersister, params.target.repoRef, params, details.afterAction)
            .then(r => ctx.messageClient.respond(`Created and pushed new project`)
            .then(() => r));
    })
        .then(r => {
        if (GitHubRepoRef_1.isGitHubRepoRef(r.target.id)) {
            return hasOrgWebhook(params.target.repoRef.owner, ctx)
                .then(webhookInstalled => {
                if (!webhookInstalled) {
                    return addAtomistWebhook_1.addAtomistWebhook(r.target, params);
                }
                else {
                    return Promise.resolve(r);
                }
            });
        }
        return Promise.resolve(r);
    })
        .then(r => ctx.messageClient.respond(`Successfully created new project`).then(() => r))
        .then(r => ({
        code: 0,
        // Redirect to our local project page
        redirect: details.redirecter(params.target.repoRef),
    }));
}
const OrgWebhookQuery = `query OrgWebhook($owner: String!) {
  Webhook(webhookType: organization) {
    org(owner: $owner) @required {
      owner
    }
  }
}`;
function hasOrgWebhook(owner, ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        const orgHooks = yield ctx.graphClient.query({
            query: OrgWebhookQuery,
            variables: {
                owner,
            },
            options: GraphClient_1.QueryNoCacheOptions,
        });
        const hookOwner = _.get(orgHooks, "Webhook[0].org.owner");
        return hookOwner === owner;
    });
}
/**
 * Retrieve a seed
 * @param {HandlerContext} ctx
 * @param {RepoLoader} repoLoader
 * @param {P} params
 * @param details command details
 * @return {Promise<Project>}
 */
function startingPoint(params, ctx, repoLoader, details) {
    return repoLoader(params.source.repoRef);
}
//# sourceMappingURL=generatorToCommand.js.map