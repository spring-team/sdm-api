"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("../../internal/util/logger");
const editModes_1 = require("../edit/editModes");
const projectEditor_1 = require("../edit/projectEditor");
/**
 * Edit a GitHub project using a PR or branch.
 * Do not attempt any git updates if (a) edited is explicitly set to false by the editor
 * or (b) edited is undefined and git status is not dirty. If edited is explicitly
 * set to true by the editor and the git status is not dirty, this is a developer error
 * which should result in a runtime error.
 * @param context handler context for this operation
 * @param p project
 * @param editor editor to use
 * @param editMode how to persist the edit
 * @param parameters to editor
 * @return EditResult instance that reports as to whether the project was actually edited
 */
function editRepo(context, p, editor, editMode, parameters) {
    const after = x => !!editMode.afterPersist ? editMode.afterPersist(p).then(() => x) : x;
    if (editModes_1.isPullRequest(editMode)) {
        return editProjectUsingPullRequest(context, p, editor, editMode, parameters)
            .then(after);
    }
    else if (editModes_1.isBranchCommit(editMode)) {
        return editProjectUsingBranch(context, p, editor, editMode, parameters)
            .then(after);
    }
    else if (editModes_1.isCustomExecutionEditMode(editMode)) {
        return editMode.edit(p, editor, context, parameters)
            .then(after);
    }
    else {
        // No edit to do
        return Promise.resolve(projectEditor_1.successfulEdit(p, true));
    }
}
exports.editRepo = editRepo;
function editProjectUsingPullRequest(context, gp, editor, pr, parameters) {
    return editor(gp, context, parameters)
        .then(r => doWithEditResult(r, () => raisePr(gp, pr)));
}
exports.editProjectUsingPullRequest = editProjectUsingPullRequest;
function editProjectUsingBranch(context, gp, editor, ci, parameters) {
    return editor(gp, context, parameters)
        .then(r => 
    // TODO fix this type cast
    doWithEditResult(r, () => createAndPushBranch(gp, ci)));
}
exports.editProjectUsingBranch = editProjectUsingBranch;
/**
 * Perform git operation on the project only if edited != false or status is dirty
 * @param {EditResult<GitProject>} r
 * @param {() => Promise<EditResult>} gitop what to do with a dirty project
 * @return {Promise<EditResult>}
 */
function doWithEditResult(r, gitop) {
    if (r.edited === true) {
        logger_1.logger.debug("Declared dirty; executing git operation. Project: %j\n Directory: %s", r.target.id, r.target.baseDir);
        return gitop();
    }
    if (r.edited === undefined) {
        // Check git status
        return r.target.gitStatus()
            .then(status => {
            if (status.isClean) {
                logger_1.logger.debug("Observed clean; skipping git operation. Project: %j\n Directory: %s", r.target.id, r.target.baseDir);
                return {
                    target: r.target,
                    success: true,
                    edited: false,
                };
            }
            else {
                logger_1.logger.debug("Observed dirty; executing git operation. Project: %j\n Directory: %s", r.target.id, r.target.baseDir);
                return gitop();
            }
        });
    }
    logger_1.logger.debug("Declared not dirty; skipping git operation. Project: %j\n Directory: %s\nEdited=%s", r.target.id, r.target.baseDir, r.edited);
    return Promise.resolve(r);
}
/**
 * Create a branch (if it doesn't exist), commit with current content and push
 * @param {GitProject} gp
 * @param {BranchCommit} ci
 */
function createAndPushBranch(gp, ci) {
    return gp.configureFromRemote()
        .then(() => gp.hasBranch(ci.branch).then(branchExists => {
        if (branchExists) {
            return gp.checkout(ci.branch);
        }
        else {
            return gp.createBranch(ci.branch); // this also checks it out
        }
    }))
        .then(x => gp.commit(ci.message))
        .then(x => gp.push())
        .then(r => projectEditor_1.successfulEdit(r.target, true));
}
exports.createAndPushBranch = createAndPushBranch;
/**
 * Raise a PR from the current state of the project
 * @param {GitProject} gp
 * @param {PullRequest} pr
 */
function raisePr(gp, pr) {
    return createAndPushBranch(gp, pr)
        .then(x => {
        return gp.raisePullRequest(pr.title, pr.body)
            .then(r => projectEditor_1.successfulEdit(gp, true));
    });
}
exports.raisePr = raisePr;
//# sourceMappingURL=editorUtils.js.map