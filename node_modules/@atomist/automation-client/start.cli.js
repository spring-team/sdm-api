#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("./internal/util/logger");
logger_1.LoggingConfig.format = "cli";
process.env.SUPPRESS_NO_CONFIG_WARNING = "true";
const yargs = require("yargs");
const commands_1 = require("./cli/commands");
const Package = "atomist";
const compileDescribe = "Run 'npm run compile' before running";
const installDescribe = "Run 'npm install' before running/compiling, default is to install if no " +
    "'node_modules' directory exists";
// tslint:disable-next-line:no-unused-expression
yargs.completion("completion")
    .command(["execute <name>", "exec <name>", "cmd <name>"], "Run a command", ya => {
    return ya // positional is not yet supported in @types/yargs
        .positional("name", {
        describe: "Name of command to run, command parameters NAME=VALUE can follow",
        required: true,
    })
        .option("change-dir", {
        alias: "C",
        default: process.cwd(),
        describe: "Path to automation client project",
        type: "string",
    })
        .option("compile", {
        default: true,
        describe: compileDescribe,
        type: "boolean",
    })
        .option("install", {
        describe: installDescribe,
        type: "boolean",
    });
}, argv => {
    const args = commands_1.extractArgs(argv._);
    const ci = {
        name: argv.name,
        args,
    };
    try {
        const status = commands_1.run(argv["change-dir"], ci, argv.install, argv.compile);
        process.exit(status);
    }
    catch (e) {
        console.error(`${Package}: Unhandled Error: ${e.message}`);
        process.exit(101);
    }
})
    .command(["start", "st", "run"], "Start an automation client", ya => {
    return ya
        .option("change-dir", {
        alias: "C",
        default: process.cwd(),
        describe: "Path to automation client project",
        type: "string",
    })
        .option("compile", {
        default: true,
        describe: compileDescribe,
        type: "boolean",
    })
        .option("install", {
        describe: installDescribe,
        type: "boolean",
    });
}, argv => {
    try {
        const status = commands_1.start(argv["change-dir"], argv.install, argv.compile);
        process.exit(status);
    }
    catch (e) {
        console.error(`${Package}: Unhandled Error: ${e.message}`);
        process.exit(101);
    }
})
    .command(["gql-fetch <team>"], "Introspect GraphQL schema", ya => {
    return ya
        .positional("team", {
        describe: "Atomist workspace/team ID",
        required: true,
    })
        .option("token", {
        alias: "T",
        describe: "Token to use for authentication",
        default: process.env.ATOMIST_TOKEN || process.env.GITHUB_TOKEN,
        type: "string",
    })
        .option("change-dir", {
        alias: "C",
        default: process.cwd(),
        describe: "Path to automation client project",
        type: "string",
    })
        .option("install", {
        describe: installDescribe,
        type: "boolean",
    });
}, argv => {
    commands_1.gqlFetch(argv["change-dir"], argv.team, argv.token, argv.install)
        .then(status => process.exit(status), err => {
        console.error(`${Package}: Unhandled Error: ${err.message}`);
        process.exit(101);
    });
})
    .command(["gql-gen <glob>", "gql <glob>"], "Generate TypeScript code for GraphQL", ya => {
    return ya
        .option("change-dir", {
        alias: "C",
        default: process.cwd(),
        describe: "Path to automation client project",
        type: "string",
    })
        .option("install", {
        describe: installDescribe,
        type: "boolean",
    });
}, argv => {
    commands_1.gqlGen(argv["change-dir"], argv.glob, argv.install)
        .then(status => process.exit(status), err => {
        console.error(`${Package}: Unhandled Error: ${err.message}`);
        process.exit(101);
    });
})
    .command("git", "Create a git-info.json file", ya => {
    return ya
        .option("change-dir", {
        alias: "C",
        describe: "Path to automation client project",
        default: process.cwd(),
    });
}, argv => {
    commands_1.gitInfo(argv)
        .then(status => process.exit(status), err => {
        console.error(`${Package}: Unhandled Error: ${err.message}`);
        process.exit(101);
    });
})
    .command("config", "Configure environment for running automation clients", ya => {
    return ya
        .option("team", {
        describe: "Atomist workspace/team ID",
        type: "string",
        alias: "slack-team",
    })
        .option("github-user", {
        describe: "GitHub user login",
        type: "string",
    })
        .option("github-password", {
        describe: "GitHub user password",
        type: "string",
    })
        .option("github-mfa-token", {
        describe: "GitHub user password",
        type: "string",
    });
}, argv => {
    commands_1.config(argv)
        .then(status => process.exit(status), err => {
        console.error(`${Package}: Unhandled Error: ${err.message}`);
        process.exit(101);
    });
})
    .showHelpOnFail(false, "Specify --help for available options")
    .alias("help", ["h", "?"])
    .version(commands_1.readVersion())
    .alias("version", "v")
    .describe("version", "Show version information")
    .demandCommand(1, "Missing command")
    .strict()
    .argv;
//# sourceMappingURL=start.cli.js.map