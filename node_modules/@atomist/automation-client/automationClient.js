"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cluster = require("cluster");
const stringify = require("json-stringify-safe");
const _ = require("lodash");
const p = require("path");
const applicationEvent_1 = require("./internal/env/applicationEvent");
const ClusterMasterRequestProcessor_1 = require("./internal/transport/cluster/ClusterMasterRequestProcessor");
const ClusterWorkerRequestProcessor_1 = require("./internal/transport/cluster/ClusterWorkerRequestProcessor");
const EventStoringAutomationEventListener_1 = require("./internal/transport/EventStoringAutomationEventListener");
const ExpressServer_1 = require("./internal/transport/express/ExpressServer");
const MetricEnabledAutomationEventListener_1 = require("./internal/transport/MetricEnabledAutomationEventListener");
const OnLog_1 = require("./internal/transport/OnLog");
const DefaultWebSocketRequestProcessor_1 = require("./internal/transport/websocket/DefaultWebSocketRequestProcessor");
const payloads_1 = require("./internal/transport/websocket/payloads");
const WebSocketClient_1 = require("./internal/transport/websocket/WebSocketClient");
const logger_1 = require("./internal/util/logger");
const string_1 = require("./internal/util/string");
const BuildableAutomationServer_1 = require("./server/BuildableAutomationServer");
const statsd_1 = require("./util/statsd");
class AutomationClient {
    constructor(configuration) {
        this.configuration = configuration;
        this.defaultListeners = [
            new MetricEnabledAutomationEventListener_1.MetricEnabledAutomationEventListener(),
            new EventStoringAutomationEventListener_1.EventStoringAutomationEventListener(),
        ];
        this.automations = new BuildableAutomationServer_1.BuildableAutomationServer(configuration);
    }
    get automationServer() {
        return this.automations;
    }
    withCommandHandler(chm) {
        this.automations.registerCommandHandler(chm);
        return this;
    }
    withEventHandler(event) {
        this.automations.registerEventHandler(event);
        return this;
    }
    withIngester(ingester) {
        this.automations.registerIngester(ingester);
        return this;
    }
    run() {
        global.__runningAutomationClient = this;
        const webSocketOptions = {
            graphUrl: this.configuration.endpoints.graphql,
            registrationUrl: this.configuration.endpoints.api,
            token: this.configuration.token,
            termination: this.configuration.ws.termination,
            compress: this.configuration.ws.compress,
            timeout: this.configuration.ws.timeout,
        };
        if (this.configuration.logging.logEvents.enabled) {
            this.withEventHandler(OnLog_1.onLogMaker(this.configuration.name, this.configuration.version, this.configuration.logging.logEvents.handlers));
        }
        logger_1.setLogLevel(this.configuration.logging.level);
        if (this.configuration.logging.file.enabled === true) {
            let filename = p.join(".", "log", `${this.configuration.name.replace(/^.*\//, "")}.log`);
            if (this.configuration.logging.file.name) {
                filename = this.configuration.logging.file.name;
            }
            logger_1.addFileTransport(filename, this.configuration.logging.file.level || this.configuration.logging.level);
        }
        if (this.configuration.statsd.enabled === true) {
            this.defaultListeners.push(new statsd_1.StatsdAutomationEventListener(this.configuration));
        }
        const clientSig = `${this.configuration.name}@${this.configuration.version}`;
        const clientConf = stringify(this.configuration, string_1.obfuscateJson);
        if (!this.configuration.cluster.enabled) {
            logger_1.logger.info(`Starting Atomist automation client ${clientSig}`);
            logger_1.logger.debug(`Using automation client configuration: ${clientConf}`);
            if (this.configuration.ws.enabled) {
                this.wsHandler = this.setupWebSocketRequestHandler(webSocketOptions);
                return Promise.all([
                    this.runWs(this.wsHandler, webSocketOptions),
                    Promise.resolve(this.runHttp()),
                    this.setupApplicationEvents(),
                ]);
            }
            else {
                return Promise.all([
                    Promise.resolve(this.runHttp()),
                    this.setupApplicationEvents(),
                ]);
            }
        }
        else if (cluster.isMaster) {
            logger_1.logger.info(`Starting Atomist automation client master ${clientSig}`);
            logger_1.logger.debug(`Using automation client configuration: ${clientConf}`);
            this.wsHandler = this.setupWebSocketClusterRequestHandler(webSocketOptions);
            return this.wsHandler.run()
                .then(() => {
                return Promise.all([
                    this.runWs(this.wsHandler, webSocketOptions),
                    Promise.resolve(this.runHttp()),
                    this.setupApplicationEvents(),
                ]);
            });
        }
        else if (cluster.isWorker) {
            logger_1.logger.info(`Starting Atomist automation client worker ${clientSig}`);
            return Promise.resolve(ClusterWorkerRequestProcessor_1.startWorker(this.automations, webSocketOptions, [...this.defaultListeners, ...this.configuration.listeners]));
        }
    }
    setupWebSocketClusterRequestHandler(webSocketOptions) {
        return new ClusterMasterRequestProcessor_1.ClusterMasterRequestProcessor(this.automations, webSocketOptions, [...this.defaultListeners, ...this.configuration.listeners], this.configuration.cluster.workers);
    }
    setupWebSocketRequestHandler(webSocketOptions) {
        return new DefaultWebSocketRequestProcessor_1.DefaultWebSocketRequestProcessor(this.automations, webSocketOptions, [...this.defaultListeners, ...this.configuration.listeners]);
    }
    setupApplicationEvents() {
        if (this.configuration.applicationEvents.enabled) {
            if (this.configuration.applicationEvents.teamId) {
                return applicationEvent_1.registerApplicationEvents(this.configuration.applicationEvents.teamId);
            }
            else if (this.configuration.teamIds.length > 0) {
                return applicationEvent_1.registerApplicationEvents(this.configuration.teamIds[0]);
            }
        }
        return Promise.resolve();
    }
    runWs(handler, options) {
        const payloadOptions = {};
        if (options.compress) {
            payloadOptions.accept_encoding = "gzip";
        }
        this.webSocketClient = new WebSocketClient_1.WebSocketClient(() => payloads_1.prepareRegistration(this.automations.automations, payloadOptions), options, handler);
        return this.webSocketClient.start();
    }
    runHttp() {
        if (!this.configuration.http.enabled) {
            return;
        }
        const expressOptions = {
            port: this.configuration.http.port,
            customizers: this.configuration.http.customizers,
            host: this.configuration.http.host,
            auth: {
                basic: _.cloneDeep(this.configuration.http.auth.basic),
                bearer: _.cloneDeep(this.configuration.http.auth.bearer),
                token: _.cloneDeep(this.configuration.http.auth.token),
            },
            endpoint: {
                graphql: this.configuration.endpoints.graphql,
            },
        };
        this.httpServer = new ExpressServer_1.ExpressServer(this.automations, [...this.defaultListeners, ...this.configuration.listeners], expressOptions);
    }
}
exports.AutomationClient = AutomationClient;
function automationClient(configuration) {
    const client = new AutomationClient(configuration);
    configuration.commands.forEach(c => {
        client.withCommandHandler(c);
    });
    configuration.events.forEach(e => {
        client.withEventHandler(e);
    });
    configuration.ingesters.forEach(e => {
        if (typeof e === "string") {
            client.withIngester(e);
        }
        else if (e.build) {
            client.withIngester(e.build());
        }
        else {
            client.withIngester(e);
        }
    });
    return client;
}
exports.automationClient = automationClient;
//# sourceMappingURL=automationClient.js.map