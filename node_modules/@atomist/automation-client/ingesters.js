"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
/**
 * Builder to construct Ingester instances fluently
 */
class IngesterBuilder {
    constructor(rootType) {
        this.rootType = rootType;
        this.types = [];
        this.enums = [];
        if (util_1.isString(rootType)) {
            this.name = rootType;
        }
        else {
            this.name = rootType.name;
            this.types.push(rootType.build(this.types));
        }
    }
    withType(builder) {
        this.types.push(builder.build(this.types));
        return this;
    }
    withEnum(builder) {
        this.enums.push(builder.build());
        return this;
    }
    build() {
        return {
            root_type: this.name,
            types: [...this.enums, ...this.types],
        };
    }
}
exports.IngesterBuilder = IngesterBuilder;
/**
 * Builder to construct TypeBuilder instances fluently
 */
class TypeBuilder {
    constructor(name, description) {
        this.name = name;
        this.description = description;
        this.fields = [];
    }
    withScalarField(name, kind, description, directives = []) {
        const field = {
            name,
            type: {
                kind: "SCALAR",
                name: kind,
            },
        };
        if (description) {
            field.description = description;
        }
        if (directives.length > 0) {
            field.directives = directives.map(d => ({ name: d }));
        }
        this.fields.push(field);
        return this;
    }
    withObjectField(name, object, description, args = [], directives = []) {
        const field = {
            name,
            args: args,
            type: {
                kind: "OBJECT",
                name: util_1.isString(object) ? object : object.name,
            },
        };
        if (description) {
            field.description = description;
        }
        if (directives.length > 0) {
            field.directives = directives.map(d => ({ name: d }));
        }
        this.fields.push(field);
        return this;
    }
    withEnumField(name, object, description, directives = []) {
        const field = {
            name,
            type: {
                kind: "ENUM",
                name: util_1.isString(object) ? object : object.name,
            },
        };
        if (description) {
            field.description = description;
        }
        if (directives.length > 0) {
            field.directives = directives.map(d => ({ name: d }));
        }
        this.fields.push(field);
        return this;
    }
    withStringField(name, description, directives = []) {
        return this.withScalarField(name, "String", description, directives);
    }
    withBooleanField(name, description, directives = []) {
        return this.withScalarField(name, "Boolean", description, directives);
    }
    withFloatField(name, description, directives = []) {
        return this.withScalarField(name, "Float", description, directives);
    }
    withIntField(name, description, directives = []) {
        return this.withScalarField(name, "Int", description, directives);
    }
    withListScalarField(name, kind, description) {
        const field = {
            name,
            type: {
                kind: "LIST",
                ofType: {
                    kind: "SCALAR",
                    name: kind,
                },
            },
        };
        if (description) {
            field.description = description;
        }
        this.fields.push(field);
        return this;
    }
    withListObjectField(name, object, description = null, args = []) {
        const field = {
            name,
            args: args,
            type: {
                kind: "LIST",
                ofType: {
                    kind: "OBJECT",
                    name: util_1.isString(object) ? object : object.name,
                },
            },
        };
        if (description) {
            field.description = description;
        }
        this.fields.push(field);
        return this;
    }
    build(types) {
        this.fields.filter(f => f.type.kind === "OBJECT" || (f.type.kind === "LIST" && f.type.ofType.kind === "OBJECT")).forEach(f => {
            f.args = (f.args || []).map(a => {
                const refType = types.find(t => t.name === (f.type.name || (f.type.ofType && f.type.ofType.name)));
                if (refType) {
                    const refFieldType = refType.fields.find(fi => fi.name === a);
                    if (refFieldType) {
                        if (refFieldType.type.kind === "OBJECT") {
                            throw new Error(`Referenced type '${f.type.name}' in arg '${a}' is of type OBJECT. Only SCALAR is supports as args`);
                        }
                        const argsType = Object.assign({}, refFieldType, { 
                            // TODO what are those default values
                            defaultValue: null, type: {
                                kind: "LIST",
                                ofType: {
                                    kind: "SCALAR",
                                    name: refFieldType.type.name,
                                },
                            } });
                        delete argsType.args;
                        delete argsType.directives;
                        return argsType;
                    }
                }
                throw new Error(`Referenced type '${f.type.name}' in arg '${a}' of field '${f.name}' in type '${this.name}' could not be found`);
            });
            if (!f.args || f.args.length === 0) {
                delete f.args;
            }
        });
        const object = {
            kind: "OBJECT",
            name: this.name,
            fields: this.fields,
        };
        if (this.description) {
            object.description = this.description;
        }
        return object;
    }
}
exports.TypeBuilder = TypeBuilder;
/**
 * Builder to construct EnumType instances fluently
 */
class EnumBuilder {
    constructor(name, values, description) {
        this.name = name;
        this.values = values;
        this.description = description;
    }
    build() {
        const enu = {
            kind: "ENUM",
            name: this.name,
            enumValues: this.values.map(v => ({ name: v })),
        };
        if (this.description) {
            enu.description = this.description;
        }
        return enu;
    }
}
exports.EnumBuilder = EnumBuilder;
/**
 * Create an IngesterBuilder for the provided rootType
 *
 * If rootType is TypeBuilder instance, it is added to the types collection.
 * Therefore there is no need to call withType on the rootType.
 * @param {string | TypeBuilder} rootType
 * @returns {IngesterBuilder}
 */
function buildIngester(rootType) {
    return new IngesterBuilder(rootType);
}
exports.buildIngester = buildIngester;
/**
 * Create a TypeBuilder for the provided name
 * @param {string} name
 * @returns {TypeBuilder}
 */
function buildType(name) {
    return new TypeBuilder(name);
}
exports.buildType = buildType;
/**
 * Create a EnumBuilder for the provided name, description and values
 * @param {string} name
 * @param {string[]} values
 * @param {string} description
 * @returns {EnumBuilder}
 */
function buildEnum(name, values, description) {
    return new EnumBuilder(name, values, description);
}
exports.buildEnum = buildEnum;
//# sourceMappingURL=ingesters.js.map