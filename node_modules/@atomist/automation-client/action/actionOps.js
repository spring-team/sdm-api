"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ActionResult_1 = require("./ActionResult");
/**
 * Chain the actions, in the given order
 * @param {ProjectEditor} steps
 * @return {ProjectEditor}
 */
function actionChain(...steps) {
    return actionChainWithCombiner((r1, r2) => (Object.assign({}, r1, r2)), ...steps);
}
exports.actionChain = actionChain;
function actionChainWithCombiner(combiner, ...steps) {
    return steps.length === 0 ?
        exports.NoAction :
        steps.reduce((c1, c2) => {
            const ed1 = toAction(c1);
            const ed2 = toAction(c2);
            return p => ed1(p).then(r1 => {
                // console.log("Applied action " + c1.toString());
                if (!r1.success) {
                    return r1;
                }
                else {
                    return ed2(r1.target).then(r2 => {
                        // console.log("Applied action " + c2.toString());
                        const combinedResult = combiner(r1, r2);
                        return combinedResult;
                    });
                }
            });
        }); // Consider adding R as a type parameter to TAction
}
exports.actionChainWithCombiner = actionChainWithCombiner;
function toAction(link) {
    return p => {
        try {
            const oneOrTheOther = link(p);
            return oneOrTheOther
                .catch(err => ActionResult_1.failureOn(p, err, link))
                .then(r => {
                // See what it returns
                return ActionResult_1.isActionResult(r) ?
                    r :
                    ActionResult_1.successOn(r);
            });
        }
        catch (error) {
            // console.error("Failure: " + error.message);
            return Promise.resolve(ActionResult_1.failureOn(p, error, link));
        }
    };
}
/**
 * Useful starting point for chaining
 */
exports.NoAction = t => Promise.resolve(ActionResult_1.successOn(t));
//# sourceMappingURL=actionOps.js.map