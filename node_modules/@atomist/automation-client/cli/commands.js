"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process = require("child_process");
const fs = require("fs-extra");
const glob = require("glob-promise");
const stringify = require("json-stringify-safe");
const path = require("path");
const logger_1 = require("../internal/util/logger");
const config_1 = require("./config");
const gitInfo_1 = require("./gitInfo");
/**
 * Parse positional parameters into parameter name/value pairs.  The
 * positional parameters should be of the form NAME[=VALUE].  If
 * =VALUE is omitted, the value is set to `undefined`.  If the VALUE
 * is empty, i.e., NAME=, then the value is the empty string.
 *
 * @param args typically argv._ from tags
 * @return array of CommandInvocation Arg
 */
function extractArgs(args) {
    return args.map(arg => {
        const split = arg.indexOf("=");
        if (split < 0) {
            return { name: arg, value: undefined };
        }
        const name = arg.slice(0, split);
        const value = arg.slice(split + 1);
        return { name, value };
    });
}
exports.extractArgs = extractArgs;
function readVersion() {
    try {
        const pj = require(path.join(__dirname, "..", "package.json"));
        return `${pj.name} ${pj.version}`;
    }
    catch (e) {
        try {
            // in case you are running locally
            const pj = require(path.join(__dirname, "..", "..", "package.json"));
            return `${pj.name} ${pj.version}`;
        }
        catch (e) {
            return "@atomist/automation-client 0.0.0";
        }
    }
}
exports.readVersion = readVersion;
function start(cwd, runInstall = true, runCompile = true) {
    const opts = {
        cmd: "start.client.js",
        args: "",
        message: "Starting Automation Client",
        cwd,
        runInstall,
        runCompile,
    };
    return execJs(opts);
}
exports.start = start;
function run(cwd, ci, runInstall = true, runCompile = true) {
    const opts = {
        cmd: "cli/run.js",
        args: `--request='${stringify(ci)}'`,
        message: `Running command '${ci.name}'`,
        cwd,
        runInstall,
        runCompile,
    };
    return execJs(opts);
}
exports.run = run;
function gqlFetch(cwd, teamId, token = process.env.ATOMIST_TOKEN || process.env.GITHUB_TOKEN, runInstall = true) {
    const outDir = path.join(cwd, "src", "graphql");
    const outSchema = path.join(outDir, "schema.json");
    return fs.ensureDir(outDir)
        .then(() => {
        const opts = {
            cmd: "apollo-codegen",
            args: `introspect-schema https://automation.atomist.com/graphql/team/${teamId} ` +
                `--output ${outSchema} --header "Authorization: token ${token}"`,
            message: `Introspecting GraphQL schema for team ${teamId}`,
            cwd,
            runInstall,
            runCompile: false,
        };
        return execBin(opts);
    });
}
exports.gqlFetch = gqlFetch;
function gqlGen(cwd, pattern, runInstall = true) {
    // Check if the project has a custom schema
    let schema = "node_modules/@atomist/automation-client/graph/schema.cortex.json";
    if (fs.existsSync(path.join(cwd, "src", "graphql", "schema.json"))) {
        schema = "./src/graphql/schema.json";
    }
    const opts = {
        cmd: "gql-gen",
        args: `--file ${schema} --template typescript --no-schema --out src/typings/types.ts`,
        message: `Running GraphQL code generator`,
        cwd,
        runInstall,
        runCompile: false,
    };
    return glob(pattern)
        .then(graphqlFiles => {
        if (graphqlFiles.length > 0) {
            opts.args += ` "${pattern}"`;
        }
    }, err => {
        logger_1.logger.warn("GraphQL file glob pattern '${pattern}' failed, continuing");
    })
        .then(() => execBin(opts));
}
exports.gqlGen = gqlGen;
function config(argv) {
    return config_1.cliAtomistConfig(argv);
}
exports.config = config;
function gitInfo(argv) {
    return gitInfo_1.cliGitInfo(argv["change-dir"]);
}
exports.gitInfo = gitInfo;
function execBin(opts) {
    opts.cwd = path.resolve(opts.cwd);
    opts.cmd = (process.platform === "win32") ? `${opts.cmd}.cmd` : opts.cmd;
    opts.cmd = path.join(opts.cwd, "node_modules", ".bin", opts.cmd);
    opts.checks = [
        () => {
            if (!fs.existsSync(opts.cmd)) {
                logger_1.logger.error(`Project at '${opts.cwd}' is not a valid automation client project: missing ${opts.cmd}`);
                return 1;
            }
            return 0;
        },
    ];
    return execCmd(opts);
}
function execJs(opts) {
    opts.cwd = path.resolve(opts.cwd);
    const script = path.join(opts.cwd, "node_modules", "@atomist", "automation-client", opts.cmd);
    opts.args = `"${script}" ${opts.args}`;
    opts.cmd = (process.platform === "win32") ? "node.exe" : "node";
    opts.checks = [
        () => {
            if (!fs.existsSync(script)) {
                logger_1.logger.error(`Project at '${opts.cwd}' is not a valid automation client project: missing ${script}`);
                return 1;
            }
            return 0;
        },
    ];
    return execCmd(opts);
}
/**
 * Synchronously execute the given command with the given arguments,
 * optionally installing and compiling first.
 *
 * @param opts the exec options
 * @return integer return value of command, 0 if command is successful
 */
function execCmd(opts) {
    // if --install or --no-install is provided, do that
    // otherwise run install only if the node_modules directory does not exist
    if (opts.runInstall === true ||
        (opts.runInstall !== false && !fs.existsSync(path.join(opts.cwd, "node_modules")))) {
        const installStatus = install(opts.cwd);
        if (installStatus !== 0) {
            return installStatus;
        }
    }
    if (opts.runCompile) {
        const compileStatus = compile(opts.cwd);
        if (compileStatus !== 0) {
            return compileStatus;
        }
    }
    for (const check of opts.checks) {
        const checkStatus = check();
        if (checkStatus !== 0) {
            return checkStatus;
        }
    }
    const command = `${opts.cmd} ${opts.args}`;
    logger_1.logger.info(`${opts.message} in '${opts.cwd}'`);
    try {
        child_process.execSync(command, { cwd: opts.cwd, stdio: "inherit", env: process.env });
    }
    catch (e) {
        console.error(`Command '${command}' failed: ${e.message}`);
        return e.status;
    }
    return 0;
}
function install(cwd) {
    logger_1.logger.info(`Running 'npm install' in '${cwd}'`);
    try {
        if (!checkPackageJson(cwd)) {
            return 1;
        }
        child_process.execSync(`npm install`, { cwd, stdio: "inherit", env: process.env });
    }
    catch (e) {
        logger_1.logger.error(`Installation failed`);
        return e.status;
    }
    return 0;
}
exports.install = install;
function compile(cwd) {
    logger_1.logger.info(`Running 'npm run compile' in '${cwd}'`);
    try {
        if (!checkPackageJson(cwd)) {
            return 1;
        }
        child_process.execSync(`npm run compile`, { cwd, stdio: "inherit", env: process.env });
    }
    catch (e) {
        logger_1.logger.error(`Compilation failed`);
        return e.status;
    }
    return 0;
}
exports.compile = compile;
function checkPackageJson(cwd) {
    const pkgPath = path.join(cwd, "package.json");
    if (!fs.existsSync(pkgPath)) {
        console.error(`No 'package.json' in '${cwd}'`);
        return false;
    }
    return true;
}
exports.checkPackageJson = checkPackageJson;
//# sourceMappingURL=commands.js.map