"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const decoratorSupport_1 = require("./internal/metadata/decoratorSupport");
const string_1 = require("./internal/util/string");
/**
 * Decorator for parameters. Adds to object properties
 */
function Parameter(details = {}) {
    return (target, propertyKey) => {
        decoratorSupport_1.declareParameter(target, propertyKey, details);
    };
}
exports.Parameter = Parameter;
/**
 * Map a local field to some other configuration item in a different system
 */
function MappedParameter(uri, required = true) {
    return (target, name) => {
        decoratorSupport_1.declareMappedParameter(target, name, uri, required);
    };
}
exports.MappedParameter = MappedParameter;
/**
 * Declare a secret an automation wants to use
 */
function Secret(uri) {
    return (target, name) => {
        decoratorSupport_1.declareSecret(target, name, uri);
    };
}
exports.Secret = Secret;
/**
 * Inject a config value from the automation-client configuration
 */
function Value(pathOrValue) {
    return (target, name) => {
        if (typeof pathOrValue === "string") {
            decoratorSupport_1.declareValue(target, name, {
                path: pathOrValue,
            });
        }
        else {
            decoratorSupport_1.declareValue(target, name, pathOrValue);
        }
    };
}
exports.Value = Value;
/**
 * Decorator for a command handler class. Implements HandleCommand
 * @param {string} description
 * @param {string[] | string} intent
 * @return {(obj: any) => any}
 * @constructor
 */
function CommandHandler(description, ...intent) {
    return (obj) => { decoratorSupport_1.declareCommandHandler(obj, description, null, intent); };
}
exports.CommandHandler = CommandHandler;
/**
 * Decorator for a configurable command handler class. Implements HandleCommand
 * @param {string} description
 * @param {string[] | string} intent
 * @return {(obj: any) => any}
 * @constructor
 */
function ConfigurableCommandHandler(description, options) {
    const intent = options.intent ? string_1.toStringArray(options.intent) : [];
    const autoSubmit = options.autoSubmit ? options.autoSubmit : false;
    return (obj) => { decoratorSupport_1.declareCommandHandler(obj, description, autoSubmit, intent); };
}
exports.ConfigurableCommandHandler = ConfigurableCommandHandler;
/**
 * Decorator for a parameter class that doesn't contain handler logic
 * @return {(obj: any) => any}
 * @constructor
 */
function Parameters() {
    return (obj) => { decoratorSupport_1.declareParameters(obj); };
}
exports.Parameters = Parameters;
function EventHandler(description, subscription) {
    return (obj) => {
        decoratorSupport_1.declareEventHandler(obj, description, subscription);
    };
}
exports.EventHandler = EventHandler;
/**
 * Decorator for tags. Sets tags on the class
 */
function Tags(...tags) {
    return (target) => {
        decoratorSupport_1.declareTags(target, tags);
    };
}
exports.Tags = Tags;
class MappedParameters {
}
MappedParameters.GitHubOwner = "atomist://github/repository/owner";
MappedParameters.GitHubOwnerWithUser = "atomist://github/repository/owner?user=true";
MappedParameters.GitHubRepository = "atomist://github/repository";
MappedParameters.GitHubAllRepositories = "atomist://github/repository?all=true";
MappedParameters.GitHubRepositoryProvider = "atomist://github/repository/provider";
MappedParameters.GitHubWebHookUrl = "atomist://github_webhook_url";
MappedParameters.GitHubUrl = "atomist://github_url";
MappedParameters.GitHubApiUrl = "atomist://github_api_url";
MappedParameters.GitHubDefaultRepositoryVisibility = "atomist://github/default_repo_visibility";
MappedParameters.GitHubUserLogin = "atomist://github/username";
MappedParameters.SlackChannel = "atomist://slack/channel";
MappedParameters.SlackChannelName = "atomist://slack/channel_name";
MappedParameters.SlackTeam = "atomist://slack/team";
MappedParameters.SlackUser = "atomist://slack/user";
MappedParameters.SlackUserName = "atomist://slack/user_name";
MappedParameters.AtomistWebhookUrlBase = "atomist://base_webhook_url";
exports.MappedParameters = MappedParameters;
class Secrets {
    static userToken(scopes) {
        scopes = string_1.toStringArray(scopes);
        if (scopes && scopes.length > 0) {
            return `${this.UserToken}?scopes=${scopes.join(",")}`;
        }
        else {
            return this.UserToken;
        }
    }
}
Secrets.OrgToken = "github://org_token";
Secrets.UserToken = "github://user_token";
exports.Secrets = Secrets;
//# sourceMappingURL=decorators.js.map