"use strict";
/*
 * Copyright Â© 2018 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const automation_client_1 = require("@atomist/automation-client");
const GraphClient_1 = require("@atomist/automation-client/spi/graph/GraphClient");
const MessageClient_1 = require("@atomist/automation-client/spi/message/MessageClient");
const retry_1 = require("@atomist/automation-client/util/retry");
const axios_1 = require("axios");
const sprintf_js_1 = require("sprintf-js");
const ImageLink_1 = require("../../../../util/webhook/ImageLink");
const executeTag_1 = require("../executeTag");
const projectVersioner_1 = require("./projectVersioner");
/**
 * Superclass for build implemented on the automation client itself, emitting appropriate events to Atomist.
 * Allows listening to a Running build
 */
class LocalBuilder {
    constructor(name, artifactStore, projectLoader) {
        this.name = name;
        this.artifactStore = artifactStore;
        this.projectLoader = projectLoader;
    }
    initiateBuild(credentials, id, addressChannels, push, log, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const as = this.artifactStore;
            const atomistTeam = context.teamId;
            const buildNumber = yield this.obtainBuildIdentifier(push, context);
            try {
                const rb = yield this.startBuild(credentials, id, atomistTeam, log, addressChannels);
                yield this.onStarted(credentials, id, push, rb, buildNumber, context);
                try {
                    const br = yield rb.buildResult;
                    yield this.onExit(credentials, id, !br.error, push, rb, buildNumber, as, context);
                    return br.error ? { code: 1, message: br.message } : automation_client_1.Success;
                }
                catch (err) {
                    yield this.onExit(credentials, id, false, push, rb, buildNumber, as, context);
                    return automation_client_1.Failure;
                }
            }
            catch (err) {
                // If we get here, the build failed before even starting
                automation_client_1.logger.warn("Build on branch %s failed on start: %j - %s", push.branch, id, err.message);
                log.write(sprintf_js_1.sprintf("Build on branch %s failed on start: %j - %s", push.branch, id, err.message));
                yield this.updateBuildStatus({ repoRef: id, team: atomistTeam, url: undefined }, "failed", push.branch, buildNumber);
                return automation_client_1.Failure;
            }
        });
    }
    onStarted(credentials, id, push, runningBuild, buildNo, context) {
        return this.updateBuildStatus(runningBuild, "started", push.branch, buildNo);
    }
    onExit(credentials, id, success, push, runningBuild, buildNo, artifactStore, context) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (success) {
                    yield this.updateBuildStatus(runningBuild, "passed", push.branch, buildNo);
                    yield this.createBuildTag(id, push, buildNo, context, credentials);
                    if (!!runningBuild.deploymentUnitFile) {
                        yield linkArtifact(credentials, runningBuild, context.teamId, artifactStore);
                    }
                    else {
                        automation_client_1.logger.warn("No artifact generated by build of %j", runningBuild.appInfo);
                    }
                }
                else {
                    yield this.updateBuildStatus(runningBuild, "failed", push.branch, buildNo);
                }
            }
            catch (err) {
                automation_client_1.logger.warn("Unexpected build exit error: %s", err);
            }
        });
    }
    updateBuildStatus(runningBuild, status, branch, buildNo) {
        automation_client_1.logger.info("Telling Atomist about a %s build on %s, sha %s, url %s", status, branch, runningBuild.repoRef.sha, runningBuild.url);
        const url = `https://webhook.atomist.com/atomist/build/teams/${runningBuild.team}`;
        const data = {
            repository: {
                owner_name: runningBuild.repoRef.owner,
                name: runningBuild.repoRef.repo,
            },
            name: `Build #${buildNo}`,
            number: +buildNo,
            type: "push",
            build_url: runningBuild.url,
            status,
            commit: runningBuild.repoRef.sha,
            branch,
            provider: "sdm",
        };
        return retry_1.doWithRetry(() => axios_1.default.post(url, data), `Update build to ${JSON.stringify(status)}`)
            .then(() => runningBuild);
    }
    obtainBuildIdentifier(push, ctx) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield ctx.graphClient.query({
                name: "SdmBuildIdentifierForRepo",
                variables: {
                    owner: [push.owner],
                    name: [push.name],
                    providerId: [push.providerId],
                },
                options: GraphClient_1.QueryNoCacheOptions,
            });
            let buildIdentifier;
            if (result.SdmBuildIdentifier && result.SdmBuildIdentifier.length === 1) {
                buildIdentifier = result.SdmBuildIdentifier[0];
            }
            else {
                buildIdentifier = {
                    identifier: "0",
                    repo: {
                        owner: push.owner,
                        name: push.name,
                        providerId: push.providerId,
                    },
                };
            }
            const bumpedBuildIdentifier = Object.assign({}, buildIdentifier, { identifier: (+buildIdentifier.identifier + 1).toString() });
            yield ctx.messageClient.send(bumpedBuildIdentifier, MessageClient_1.addressEvent("SdmBuildIdentifier"));
            return bumpedBuildIdentifier.identifier;
        });
    }
    createBuildTag(id, push, buildNo, context, credentials) {
        return __awaiter(this, void 0, void 0, function* () {
            const version = yield projectVersioner_1.readSdmVersion(push.owner, push.name, push.providerId, push.sha, id.branch, context);
            if (version) {
                yield executeTag_1.createTagForStatus(id, push.sha, "Tag created by SDM", `${version}+sdm.${buildNo}`, credentials);
            }
        });
    }
}
exports.LocalBuilder = LocalBuilder;
function linkArtifact(creds, rb, team, artifactStore) {
    return artifactStore.storeFile(rb.appInfo, rb.deploymentUnitFile, creds)
        .then(imageUrl => ImageLink_1.postLinkImageWebhook(rb.repoRef.owner, rb.repoRef.repo, rb.repoRef.sha, imageUrl, team));
}
//# sourceMappingURL=LocalBuilder.js.map